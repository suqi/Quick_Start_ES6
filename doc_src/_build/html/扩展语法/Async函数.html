<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>async 函数的用法 &mdash; Quick_Start_ES6 mit 文档</title>
    
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootswatch-3.3.6/lumen/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     'mit',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.3.6/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="top" title="Quick_Start_ES6 mit 文档" href="../index.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body role="document">

  <div id="navbar" class="navbar navbar-inverse navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html"><span><img src="../_static/my_logo.png"></span>
          Quick_Start_ES6</a>
        <span class="navbar-text navbar-version pull-left"><b>0.1.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="http://blog.hszofficial.site/">Home</a></li>
                <li><a href="http://blog.hszofficial.site/about/">About</a></li>
                <li><a href="http://blog.hszofficial.site/series/">Series</a></li>
                <li><a href="http://blog.hszofficial.site/collection/">Collections</a></li>
                <li><a href="http://blog.hszofficial.site/tags/">Tags</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Quick_Start_ES6 <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <p>Async函数是ES7标准,它的出现使得异步操作变得更加方便。async函数是什么？一句话，async函数就是Generator函数的语法糖。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="o">*</span> <span class="nx">as</span> <span class="nx">fs</span> <span class="nx">from</span> <span class="s2">&quot;fs&quot;</span>
<span class="kr">import</span> <span class="s1">&#39;babel-polyfill&#39;</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="p">{}</span>
</pre></div>
</div>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">readFile</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">fileName</span><span class="p">){</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">){</span>
    <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="nx">fileName</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">,</span> <span class="nx">data</span><span class="p">){</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span>
      <span class="nx">resolve</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
    <span class="p">})</span>
  <span class="p">})</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="s1">&#39;use strict&#39;</span>
</pre></div>
</div>
<p>生成器写法:</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">gen</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">(){</span>
  <span class="kd">var</span> <span class="nx">f1</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">readFile</span><span class="p">(</span><span class="s1">&#39;/etc/fstab&#39;</span><span class="p">)</span>
  <span class="kd">var</span> <span class="nx">f2</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">readFile</span><span class="p">(</span><span class="s1">&#39;/etc/shells&#39;</span><span class="p">)</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">f1</span><span class="p">.</span><span class="nx">toString</span><span class="p">())</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">f2</span><span class="p">.</span><span class="nx">toString</span><span class="p">())</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="s1">&#39;use strict&#39;</span>
</pre></div>
</div>
<p>Async写法:</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">asyncReadFile</span> <span class="o">=</span> <span class="nx">async</span> <span class="kd">function</span> <span class="p">(){</span>
  <span class="kd">var</span> <span class="nx">f1</span> <span class="o">=</span> <span class="nx">await</span> <span class="nx">readFile</span><span class="p">(</span><span class="s1">&#39;./README.md&#39;</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">f2</span> <span class="o">=</span> <span class="nx">await</span> <span class="nx">readFile</span><span class="p">(</span><span class="s1">&#39;./package.json&#39;</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">f1</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">f2</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="s1">&#39;use strict&#39;</span>
</pre></div>
</div>
<p>一比较就会发现，async函数就是将Generator函数的星号（*）替换成async，将yield替换成await，仅此而已。</p>
<p>async函数对 Generator 函数的改进，体现在以下四点。</p>
<ul class="simple">
<li>内置执行器。Generator函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。</li>
</ul>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">asyncReadFile</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>&#39;use strict&#39;



# ES6快速入门

本文主要是为已经学过python的人而写的攻略文,数据科学家除了要会收集分析数据,同样需要掌握一些web技术,
这样才可以做数据可视化.Js作为web技术的标志和基础自然是不可能不学习的.直接从ES6标准入手的好处是:

+ 语法糖丰富

    低版本的Js语法简单而且坑多,使用起来各种不方便,会给习惯python的数据科学研究人员造成学习困难,
    ES6新增了大量语法糖.在使用上可以给被python惯坏了的人一定程度上减少学习成本.

+ 接近Python的开发习惯

    Python是模块化编程的语言,而Js在设计初期就没考虑太多模块化的问题,低版本的js在编写时模块化方面
    会让被python惯坏了的人非常不喜欢,ES6使用类似python的`import`语句,相对容易接受.

+ 可以顺利过渡学习JSX和react

    前端开发框架react使用组件化思路构建web前端应用,相对更加接近python等语言中编写GUI的方式,而且
    该框架比较程序员思维,类似搭积木式的编写方式也更加接近python用户习惯

事实上Js语言是比python有活力的多的一门编程语言,它充分体现着开源的魅力和模块化的威力,在google v8引擎的
性能保证下,Js语言是当今最受欢迎并且发展最快的语言没有之一,作为一个pythoner我们也确实该看看它有些什么可取之处.

在后面的几部分中我们会从分以下几个步骤与python对比着快速入门ES6

1. 环境与基本工具链:

    + node.js,npm包管理工具与babel转换器
    + 文档,代码风格检验与测试框架
    + 工作流工具链

2. 基本语法

    + 值与运算
    + 基本容器
    + 逻辑表达式,控制结构与特殊对象Fuction
    + 生成器对象
    + 特殊对象RegExp和Date
    + 变量,声明与作用域
    + 对象,类与面向对象编程
    + 异步操作
    + 二进制数组
    + 代理与反射
    + 模块化编程

3. ES7新特性

    + 装饰器
    
本文主要参考自阮一峰大大的书`&lt;ECMAScript 6 入门&gt;`,这本书讲解ES6语法相当好,评论中也有不少有用的知识,只是ES6标准事实上
基本上得靠babel转换器实现,而它又是一个高度模块化的项目,加上js资源非常丰富,同样的功能有大量的实现,部署环境就已经是一个非
常不容易的工程了,相比而言反而ES6语法部分学起来反而没啥太大难度.简单说就是这本书并不适用于我所面向的对象.所以只能在大量参
考的基础上加上具体的使用方式和环境配置方面的文字了.
{
  &quot;name&quot;: &quot;quick_start&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;ES6快速入门&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: {
    &quot;babel-cli&quot;: &quot;^6.7.5&quot;,
    &quot;babel-core&quot;: &quot;^6.7.6&quot;,
    &quot;babel-plugin-syntax-decorators&quot;: &quot;^6.3.13&quot;,
    &quot;babel-plugin-transform-decorators-legacy&quot;: &quot;^1.3.4&quot;,
    &quot;babel-plugin-transform-runtime&quot;: &quot;^6.7.5&quot;,
    &quot;babel-polyfill&quot;: &quot;^6.7.4&quot;,
    &quot;babel-preset-es2015&quot;: &quot;^6.6.0&quot;,
    &quot;babel-preset-stage-0&quot;: &quot;^6.5.0&quot;,
    &quot;babel-preset-stage-1&quot;: &quot;^6.5.0&quot;,
    &quot;babel-preset-stage-2&quot;: &quot;^6.5.0&quot;,
    &quot;babel-preset-stage-3&quot;: &quot;^6.5.0&quot;,
    &quot;babel-register&quot;: &quot;^6.7.2&quot;,
    &quot;co&quot;: &quot;^4.6.0&quot;,
    &quot;eslint&quot;: &quot;^2.7.0&quot;,
    &quot;node-fetch&quot;: &quot;^1.5.1&quot;,
    &quot;thunkify&quot;: &quot;^2.1.2&quot;
  },
  &quot;babel&quot;: {
    &quot;presets&quot;: [
      &quot;es2015&quot;,
      &quot;stage-0&quot;
    ],
    &quot;plugins&quot;: [
      &quot;syntax-decorators&quot;,
      &quot;transform-runtime&quot;
    ]
  },
  &quot;dependencies&quot;: {
    &quot;babel-runtime&quot;: &quot;^6.6.1&quot;
  }
}
</pre></div>
</div>
<p>上面的代码调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像Generator函数，需要调用next方法，或者用co模块，才能得到真正执行，得到最后结果。</p>
<ul class="simple">
<li>更好的语义。async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</li>
<li>更广的适用性。 co模块约定，yield命令后面只能是Thunk函数或Promise对象，而async函数的await命令后面，可以是Promise对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</li>
<li>返回值是Promise。async函数的返回值是Promise对象，这比Generator函数的返回值是Iterator对象方便多了。你可以用then方法指定下一步的操作。</li>
</ul>
<p>进一步说，async函数完全可以看作多个异步操作，包装成的一个Promise对象，而await命令就是内部then命令的语法糖。</p>
<p>正常情况下，await命令后面是一个Promise对象，否则会被转成Promise。</p>
<p>async函数是非常新的语法功能，新到都不属于 ES6，而是属于 ES7。目前，它仍处于提案阶段，但是转码器Babel和regenerator都已经支持，转码后就能使用。</p>
<div class="section" id="async">
<span id="async"></span><h1>async 函数的用法<a class="headerlink" href="#async" title="永久链接至标题">¶</a></h1>
<p>同Generator函数一样，async函数返回一个Promise对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。</p>
<p>下面是一个例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">async</span> <span class="kd">function</span> <span class="nx">getStockPriceByName</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">symbol</span> <span class="o">=</span> <span class="nx">await</span> <span class="nx">getStockSymbol</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
  <span class="kd">var</span> <span class="nx">stockPrice</span> <span class="o">=</span> <span class="nx">await</span> <span class="nx">getStockPrice</span><span class="p">(</span><span class="nx">symbol</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">stockPrice</span>
<span class="p">}</span>

<span class="nx">getStockPriceByName</span><span class="p">(</span><span class="s1">&#39;goog&#39;</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
<span class="p">})</span>
</pre></div>
</div>
<p>上面代码是一个获取股票报价的函数，函数前面的async关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个Promise对象。</p>
<p>下面的例子，指定多少毫秒后输出一个值。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">timeout</span><span class="p">(</span><span class="nx">ms</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">ms</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="nx">async</span> <span class="kd">function</span> <span class="nx">asyncPrint</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">ms</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">await</span> <span class="nx">timeout</span><span class="p">(</span><span class="nx">ms</span><span class="p">)</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">asyncPrint</span><span class="p">(</span><span class="s1">&#39;hello world&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
<p>上面代码指定50毫秒以后，输出&#8221;hello world&#8221;。</p>
<p>Async函数有多种使用形式。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 函数声明</span>
<span class="nx">async</span> <span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{}</span>
</pre></div>
</div>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 函数表达式</span>
<span class="kr">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="nx">async</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{};</span>
</pre></div>
</div>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 对象的方法</span>
<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">async</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{}</span> <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 箭头函数</span>
<span class="kr">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="nx">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{};</span>
</pre></div>
</div>
<p>注意:</p>
<ul class="simple">
<li>第一点，await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try...catch代码块中。</li>
</ul>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">async</span> <span class="kd">function</span> <span class="nx">myFunction</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="nx">await</span> <span class="nx">somethingThatReturnsAPromise</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 另一种写法</span>

<span class="nx">async</span> <span class="kd">function</span> <span class="nx">myFunction</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">await</span> <span class="nx">somethingThatReturnsAPromise</span><span class="p">().</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li>第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</li>
</ul>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="nx">await</span> <span class="nx">getFoo</span><span class="p">()</span>
<span class="kd">let</span> <span class="nx">bar</span> <span class="o">=</span> <span class="nx">await</span> <span class="nx">getBar</span><span class="p">()</span>
</pre></div>
</div>
<p>上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 写法一</span>
<span class="kd">let</span> <span class="p">[</span><span class="nx">foo</span><span class="p">,</span> <span class="nx">bar</span><span class="p">]</span> <span class="o">=</span> <span class="nx">await</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="nx">getFoo</span><span class="p">(),</span> <span class="nx">getBar</span><span class="p">()])</span>

<span class="c1">// 写法二</span>
<span class="kd">let</span> <span class="nx">fooPromise</span> <span class="o">=</span> <span class="nx">getFoo</span><span class="p">()</span>
<span class="kd">let</span> <span class="nx">barPromise</span> <span class="o">=</span> <span class="nx">getBar</span><span class="p">()</span>
<span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="nx">await</span> <span class="nx">fooPromise</span>
<span class="kd">let</span> <span class="nx">bar</span> <span class="o">=</span> <span class="nx">await</span> <span class="nx">barPromise</span>
</pre></div>
</div>
<p>上面两种写法，getFoo和getBar都是同时触发，这样就会缩短程序的执行时间。</p>
<ul class="simple">
<li>第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。</li>
</ul>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">async</span> <span class="kd">function</span> <span class="nx">dbFuc</span><span class="p">(</span><span class="nx">db</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">docs</span> <span class="o">=</span> <span class="p">[{},</span> <span class="p">{},</span> <span class="p">{}]</span>

  <span class="c1">// 报错</span>
  <span class="nx">docs</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">doc</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">await</span> <span class="nx">db</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码会报错，因为await用在普通函数之中了。但是，如果将forEach方法的参数改成async函数，也有问题。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">async</span> <span class="kd">function</span> <span class="nx">dbFuc</span><span class="p">(</span><span class="nx">db</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">docs</span> <span class="o">=</span> <span class="p">[{},</span> <span class="p">{},</span> <span class="p">{}]</span>

  <span class="c1">// 可能得到错误结果</span>
  <span class="nx">docs</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">async</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">doc</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">await</span> <span class="nx">db</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span>
  <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码可能不会正常工作，原因是这时三个db.post操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用for循环。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">async</span> <span class="kd">function</span> <span class="nx">dbFuc</span><span class="p">(</span><span class="nx">db</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">docs</span> <span class="o">=</span> <span class="p">[{},</span> <span class="p">{},</span> <span class="p">{}]</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">doc</span> <span class="k">of</span> <span class="nx">docs</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">await</span> <span class="nx">db</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果确实希望多个请求并发执行，可以使用Promise.all方法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">async</span> <span class="kd">function</span> <span class="nx">dbFuc</span><span class="p">(</span><span class="nx">db</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">docs</span> <span class="o">=</span> <span class="p">[{},</span> <span class="p">{},</span> <span class="p">{}]</span>
  <span class="kd">let</span> <span class="nx">promises</span> <span class="o">=</span> <span class="nx">docs</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">doc</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">db</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="nx">doc</span><span class="p">))</span>

  <span class="kd">let</span> <span class="nx">results</span> <span class="o">=</span> <span class="nx">await</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span><span class="nx">promises</span><span class="p">)</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">results</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 或者使用下面的写法</span>

<span class="nx">async</span> <span class="kd">function</span> <span class="nx">dbFuc</span><span class="p">(</span><span class="nx">db</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">docs</span> <span class="o">=</span> <span class="p">[{},</span> <span class="p">{},</span> <span class="p">{}]</span>
  <span class="kd">let</span> <span class="nx">promises</span> <span class="o">=</span> <span class="nx">docs</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">doc</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">db</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="nx">doc</span><span class="p">))</span>

  <span class="kd">let</span> <span class="nx">results</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">promise</span> <span class="k">of</span> <span class="nx">promises</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">results</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">await</span> <span class="nx">promise</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">results</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ES6将await增加为保留字。使用这个词作为标识符，在ES5是合法的，在ES6将抛出SyntaxError。</p>
</div>
<div class="section" id="promisegenerator">
<span id="promisegenerator"></span><h1>与Promise、Generator的比较<a class="headerlink" href="#promisegenerator" title="永久链接至标题">¶</a></h1>
<p>我们通过一个例子，来看Async函数与Promise、Generator函数的区别。</p>
<p>假定某个DOM元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</p>
<p>首先是Promise的写法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">chainAnimationsPromise</span><span class="p">(</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">animations</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// 变量ret用来保存上一个动画的返回值</span>
  <span class="kd">var</span> <span class="nx">ret</span> <span class="o">=</span> <span class="kc">null</span>

  <span class="c1">// 新建一个空的Promise</span>
  <span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">()</span>

  <span class="c1">// 使用then方法，添加所有动画</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">anim</span> <span class="k">in</span> <span class="nx">animations</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">p</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">ret</span> <span class="o">=</span> <span class="nx">val</span>
      <span class="k">return</span> <span class="nx">anim</span><span class="p">(</span><span class="nx">elem</span><span class="p">)</span>
    <span class="p">})</span>
  <span class="p">}</span>

  <span class="c1">// 返回一个部署了错误捕捉机制的Promise</span>
  <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* 忽略错误，继续执行 */</span>
  <span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">ret</span>
  <span class="p">})</span>

<span class="p">}</span>
</pre></div>
</div>
<p>虽然Promise的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是Promise的API（then、catch等等），操作本身的语义反而不容易看出来。</p>
<p>接着是Generator函数的写法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">chainAnimationsGenerator</span><span class="p">(</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">animations</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">return</span> <span class="nx">spawn</span><span class="p">(</span><span class="kd">function</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">ret</span> <span class="o">=</span> <span class="kc">null</span>
    <span class="k">try</span> <span class="p">{</span>
      <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">anim</span> <span class="k">of</span> <span class="nx">animations</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">ret</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">anim</span><span class="p">(</span><span class="nx">elem</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
      <span class="cm">/* 忽略错误，继续执行 */</span>
    <span class="p">}</span>
      <span class="k">return</span> <span class="nx">ret</span>
  <span class="p">})</span>

<span class="p">}</span>
</pre></div>
</div>
<p>上面代码使用Generator函数遍历了每个动画，语义比Promise写法更清晰，用户定义的操作全部都出现在spawn函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行Generator函数，上面代码的spawn函数就是自动执行器，它返回一个Promise对象，而且必须保证yield语句后面的表达式，必须返回一个Promise。</p>
<p>最后是Async函数的写法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">async</span> <span class="kd">function</span> <span class="nx">chainAnimationsAsync</span><span class="p">(</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">animations</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">ret</span> <span class="o">=</span> <span class="kc">null</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">anim</span> <span class="k">of</span> <span class="nx">animations</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">ret</span> <span class="o">=</span> <span class="nx">await</span> <span class="nx">anim</span><span class="p">(</span><span class="nx">elem</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* 忽略错误，继续执行 */</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>
</pre></div>
</div>
<p>可以看到Async函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将Generator写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用Generator写法，自动执行器需要用户自己提供。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="../_sources/扩展语法/Async函数.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; 版权所有 2016, hsz.<br/>
      由 <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.5 创建。<br/>
    </p>
  </div>
</footer>
  </body>
</html>