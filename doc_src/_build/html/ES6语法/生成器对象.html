<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>yield语句 &mdash; Quick_Start_ES6 mit 文档</title>
    
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootswatch-3.3.6/lumen/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     'mit',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.3.6/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="top" title="Quick_Start_ES6 mit 文档" href="../index.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body role="document">

  <div id="navbar" class="navbar navbar-inverse navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html"><span><img src="../_static/my_logo.png"></span>
          Quick_Start_ES6</a>
        <span class="navbar-text navbar-version pull-left"><b>0.1.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="http://blog.hszofficial.site/">Home</a></li>
                <li><a href="http://blog.hszofficial.site/about/">About</a></li>
                <li><a href="http://blog.hszofficial.site/series/">Series</a></li>
                <li><a href="http://blog.hszofficial.site/collection/">Collections</a></li>
                <li><a href="http://blog.hszofficial.site/tags/">Tags</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Quick_Start_ES6 <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <p>生成器generator是从其他语言中弄出来的新语法,和python一样,生成器的作用也是构造无限流和实现异步协程,异步部分会在后面细讲</p>
<p>生成器的定义方式和function差不多,只是关键字function后面添个<code class="docutils literal"><span class="pre">*</span></code>号,return 改成 yield</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="s1">&#39;babel-polyfill&#39;</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="p">{}</span>
</pre></div>
</div>
<blockquote>
<div>斐波那契数的生成器</div></blockquote>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">N</span><span class="p">){</span>
    <span class="kd">let</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="kd">let</span> <span class="nx">first</span> <span class="o">=</span><span class="mi">0</span>
    <span class="kd">let</span> <span class="nx">second</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="kd">let</span> <span class="nx">temp</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">n</span> <span class="o">&lt;</span> <span class="nx">N</span><span class="p">){</span>
        <span class="k">yield</span> <span class="nx">second</span>
        <span class="nx">temp</span><span class="o">=</span> <span class="nx">first</span><span class="o">+</span><span class="nx">second</span>
        <span class="nx">first</span><span class="o">=</span><span class="nx">second</span>
        <span class="nx">second</span> <span class="o">=</span> <span class="nx">temp</span>
        <span class="nx">n</span> <span class="o">+=</span><span class="mi">1</span>     
    <span class="p">}</span> 
    <span class="k">return</span> <span class="nx">second</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="s1">&#39;use strict&#39;</span>
</pre></div>
</div>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="k">of</span> <span class="nx">fib</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="mi">1</span>
<span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
<span class="mi">5</span>





<span class="n">undefined</span>
</pre></div>
</div>
<div class="section" id="yield">
<span id="yield"></span><h1>yield语句<a class="headerlink" href="#yield" title="永久链接至标题">¶</a></h1>
<p>与python中一样,生成器中的yield其实起到一个暂停断点的作用,它的逻辑如下:</p>
<ul class="simple">
<li>遇到yield语句，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。</li>
<li>下一次调用next方法时，再继续往下执行，直到遇到下一个yield语句。</li>
<li>如果没有再遇到新的yield语句，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。</li>
<li>如果该函数没有return语句，则返回的对象的value属性值为undefined。</li>
</ul>
<p>需要注意的是，yield语句后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，和python一样,这是js的惰性求值（Lazy Evaluation）的主要实现。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span>  <span class="mi">123</span> <span class="o">+</span> <span class="mi">456</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码中，yield后面的表达式123 + 456，不会立即求值，只会在next方法将指针移到这一句时，才会求值。</p>
<p>可以从上面的规则看出,js的生成器可以不带yield,这也是和python中不同的地方,
Generator不带yield语句，这时就变成了一个单纯的暂缓执行函数。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;执行了！&#39;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">generator</span> <span class="o">=</span> <span class="nx">f</span><span class="p">()</span>

<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">generator</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
<span class="p">},</span>
<span class="mi">2000</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>{ _called: false,
  _idleTimeout: 2000,
  _idlePrev: 
   Timer {
     &#39;0&#39;: [Function: listOnTimeout],
     _idleNext: [Circular],
     _idlePrev: [Circular],
     msecs: 2000 },
  _idleNext: 
   Timer {
     &#39;0&#39;: [Function: listOnTimeout],
     _idleNext: [Circular],
     _idlePrev: [Circular],
     msecs: 2000 },
  _idleStart: 3303829,
  _onTimeout: [Function],
  _repeat: null }



执行了！
</pre></div>
</div>
<p>上面代码中，函数f如果是普通函数，在为变量generator赋值时就会执行。但是，函数f是一个Generator函数，就变成只有调用next方法时，函数f才会执行。</p>
<p>另外需要注意，yield语句不能用在普通函数中，否则会报错。</p>
<p>下面是另外一个例子。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]];</span>

<span class="kd">let</span> <span class="nx">flat</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">length</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">item</span> <span class="o">=</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">item</span> <span class="o">!==</span> <span class="s1">&#39;number&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">yield</span><span class="o">*</span> <span class="nx">flat</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">yield</span> <span class="nx">item</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">f</span> <span class="k">of</span> <span class="nx">flat</span><span class="p">(</span><span class="nx">arr</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
<span class="mi">4</span>
<span class="mi">5</span>
<span class="mi">6</span>





<span class="n">undefined</span>
</pre></div>
</div>
<p>另外，yield语句如果用在一个表达式之中，必须放在圆括号里面。
yield语句用作函数参数或赋值表达式的右边，可以不加括号。</p>
<div class="section" id="yield">
<span id="id1"></span><h2>yield*<a class="headerlink" href="#yield" title="永久链接至标题">¶</a></h2>
<p>如果在Generater函数内部，调用另一个Generator函数，默认情况下是没有效果的。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="s1">&#39;a&#39;</span>
  <span class="k">yield</span> <span class="s1">&#39;b&#39;</span>
<span class="p">}</span>

<span class="kd">function</span><span class="o">*</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="s1">&#39;x&#39;</span>
  <span class="nx">foo</span><span class="p">()</span>
  <span class="k">yield</span> <span class="s1">&#39;y&#39;</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">v</span> <span class="k">of</span> <span class="nx">bar</span><span class="p">()){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// &quot;x&quot;</span>
<span class="c1">// &quot;y&quot;</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span>
<span class="n">y</span>





<span class="n">undefined</span>
</pre></div>
</div>
<p>上面代码中，foo和bar都是Generator函数，在bar里面调用foo，是不会有效果的。</p>
<p>这个就需要用到<code class="docutils literal"><span class="pre">yield*</span></code>语句，用来在一个Generator函数里面执行另一个Generator函数。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="s1">&#39;x&#39;</span>
  <span class="k">yield</span><span class="o">*</span> <span class="nx">foo</span><span class="p">()</span>
  <span class="k">yield</span> <span class="s1">&#39;y&#39;</span>
<span class="p">}</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">v</span> <span class="k">of</span> <span class="nx">bar</span><span class="p">()){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span>
<span class="n">a</span>
<span class="n">b</span>
<span class="n">y</span>





<span class="n">undefined</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">yield*</span></code>语句等同于在Generator函数内部，部署一个for...of循环,如果<code class="docutils literal"><span class="pre">yield*</span></code>后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员,否则必须使用一个带Iterator接口的对象才行</p>
<blockquote>
<div>使用<code class="docutils literal"><span class="pre">yield*</span></code>语句遍历完全二叉树。</div></blockquote>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="c1">// 下面是二叉树的构造函数，</span>
<span class="c1">// 三个参数分别是左树、当前节点和右树</span>
<span class="kd">function</span> <span class="nx">Tree</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">label</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="nx">left</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">label</span> <span class="o">=</span> <span class="nx">label</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="nx">right</span>
<span class="p">}</span>

<span class="c1">// 下面是中序（inorder）遍历函数。</span>
<span class="c1">// 由于返回的是一个遍历器，所以要用generator函数。</span>
<span class="c1">// 函数体内采用递归算法，所以左树和右树要用yield*遍历</span>
<span class="kd">function</span><span class="o">*</span> <span class="nx">inorder</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">yield</span><span class="o">*</span> <span class="nx">inorder</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span>
    <span class="k">yield</span> <span class="nx">t</span><span class="p">.</span><span class="nx">label</span>
    <span class="k">yield</span><span class="o">*</span> <span class="nx">inorder</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 下面生成二叉树</span>
<span class="kd">function</span> <span class="nx">make</span><span class="p">(</span><span class="nx">array</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 判断是否为叶节点</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">array</span><span class="p">.</span><span class="nx">length</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="k">new</span> <span class="nx">Tree</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">array</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">null</span><span class="p">);</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nx">Tree</span><span class="p">(</span><span class="nx">make</span><span class="p">(</span><span class="nx">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nx">array</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">make</span><span class="p">(</span><span class="nx">array</span><span class="p">[</span><span class="mi">2</span><span class="p">]));</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">tree</span> <span class="o">=</span> <span class="nx">make</span><span class="p">([[[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">]],</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="p">[[</span><span class="s1">&#39;e&#39;</span><span class="p">],</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;g&#39;</span><span class="p">]]]);</span>

<span class="c1">// 遍历二叉树</span>
<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">node</span> <span class="k">of</span> <span class="nx">inorder</span><span class="p">(</span><span class="nx">tree</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">result</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="p">[</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span> <span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="generatorthis">
<span id="generatorthis"></span><h2>Generator函数的this<a class="headerlink" href="#generatorthis" title="永久链接至标题">¶</a></h2>
<p>Generator函数总是返回一个遍历器，ES6规定这个遍历器是Generator函数的实例，也继承了Generator函数的prototype对象上的方法。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">g</span><span class="p">()</span> <span class="p">{}</span>

<span class="nx">g</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">hello</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s1">&#39;hi!&#39;</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nx">g</span><span class="p">();</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span> <span class="k">instanceof</span> <span class="nx">g</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">hello</span><span class="p">())</span> <span class="c1">// &#39;hi!&#39;</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>true
hi!





undefined
</pre></div>
</div>
<p>上面代码表明，Generator函数g返回的遍历器obj，是g的实例，而且继承了g.prototype。但是，如果把g当作普通的构造函数，并不会生效，因为g返回的总是遍历器对象，而不是this对象。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">g</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">11</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nx">g</span><span class="p">()</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">a</span> <span class="c1">// undefined</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">undefined</span>
</pre></div>
</div>
<p>上面代码中，Generator函数g在this对象上面添加了一个属性a，但是obj对象拿不到这个属性。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">F</span><span class="p">(){</span>
  <span class="k">yield</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="k">yield</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="mi">3</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="s1">&#39;use strict&#39;</span>
</pre></div>
</div>
<p>上面代码中，函数F是一个构造函数，又是一个Generator函数。这时，使用new命令就无法生成F的实例了，因为F返回的是一个内部指针。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="s1">&#39;next&#39;</span> <span class="k">in</span> <span class="p">(</span><span class="k">new</span> <span class="nx">F</span><span class="p">())</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">true</span>
</pre></div>
</div>
<p>上面代码中，由于new F()返回的是一个Iterator对象，具有next方法，所以上面的表达式为true。</p>
<p>如果要把Generator函数当作正常的构造函数使用，可以采用下面的变通方法。首先，生成一个空对象，使用bind方法绑定Generator函数内部的this。这样，构造函数调用以后，这个空对象就是Generator函数的实例对象了。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">F</span><span class="p">(){</span>
  <span class="k">yield</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="k">yield</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="mi">3</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{}</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">F</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">obj</span><span class="p">)()</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">next</span><span class="p">())</span>  <span class="c1">// Object {value: 2, done: false}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">next</span><span class="p">())</span> <span class="c1">// Object {value: 3, done: false}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">next</span><span class="p">())</span>  <span class="c1">// Object {value: undefined, done: true}</span>

<span class="nx">obj</span> <span class="c1">// { x: 2, y: 3 }</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">done</span><span class="p">:</span> <span class="n">false</span> <span class="p">}</span>
<span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="n">done</span><span class="p">:</span> <span class="n">false</span> <span class="p">}</span>
<span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="n">undefined</span><span class="p">,</span> <span class="n">done</span><span class="p">:</span> <span class="n">true</span> <span class="p">}</span>





<span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">3</span> <span class="p">}</span>
</pre></div>
</div>
<p>上面代码中，首先是F内部的this对象绑定obj对象，然后调用它，返回一个Iterator对象。这个对象执行三次next方法（因为F内部有两个yield语句），完成F内部所有代码的运行。这时，所有内部属性都绑定在obj对象上了，因此obj对象也就成了F的实例。</p>
</div>
<div class="section" id="generatorthrow">
<span id="generatorthrow"></span><h2>Generator对象的throw()<a class="headerlink" href="#generatorthrow" title="永久链接至标题">¶</a></h2>
<p>Generator函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在Generator函数体内捕获。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">g</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="k">yield</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;内部捕获&#39;</span><span class="p">,</span> <span class="nx">e</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">g</span><span class="p">()</span>
<span class="nx">i</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>

<span class="k">try</span> <span class="p">{</span>
  <span class="nx">i</span><span class="p">.</span><span class="k">throw</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
  <span class="nx">i</span><span class="p">.</span><span class="k">throw</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;外部捕获&#39;</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>内部捕获 a
外部捕获 b





undefined
</pre></div>
</div>
<p>上面代码中，遍历器对象i连续抛出两个错误。第一个错误被Generator函数体内的catch语句捕获。i第二次抛出错误，由于Generator函数内部的catch语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了Generator函数体，被函数体外的catch语句捕获。</p>
<p>注意，不要混淆遍历器对象的throw方法和全局的throw命令。上面代码的错误，是用遍历器对象的throw方法抛出的，而不是用throw命令抛出的。后者只能被函数体外的catch语句捕获。</p>
</div>
<div class="section" id="generatorreturn">
<span id="generatorreturn"></span><h2>Generator对象的return()<a class="headerlink" href="#generatorreturn" title="永久链接至标题">¶</a></h2>
<p>Generator函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历Generator函数。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">())</span>        <span class="c1">// { value: 1, done: false }</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">g</span><span class="p">.</span><span class="k">return</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">))</span> <span class="c1">// { value: &quot;foo&quot;, done: true }</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">())</span>      <span class="c1">// { value: undefined, done: true }</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">done</span><span class="p">:</span> <span class="n">false</span> <span class="p">}</span>
<span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="n">done</span><span class="p">:</span> <span class="n">true</span> <span class="p">}</span>
<span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="n">undefined</span><span class="p">,</span> <span class="n">done</span><span class="p">:</span> <span class="n">true</span> <span class="p">}</span>





<span class="n">undefined</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="generator">
<span id="generator"></span><h1>作为对象属性的Generator函数<a class="headerlink" href="#generator" title="永久链接至标题">¶</a></h1>
<p>如果一个对象的属性是Generator函数，可以简写成下面的形式</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span>let obj = {
  * myGeneratorMethod() {
    ···
  }
}
</pre></div>
</div>
<p>上面代码中，myGeneratorMethod属性前面有一个星号，表示这个属性是一个Generator函数。</p>
<p>完整的写法是:</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">myGeneratorMethod</span><span class="o">:</span> <span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ···</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="iterator">
<span id="iterator"></span><h1>与Iterator接口的关系<a class="headerlink" href="#iterator" title="永久链接至标题">¶</a></h1>
<p>任意一个对象的Symbol.iterator方法，等于该对象的遍历器对象生成函数，调用该函数会返回该对象的一个遍历器对象。</p>
<p>遍历器对象本身也有Symbol.iterator方法，执行后返回自身。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">(){</span>
  <span class="c1">// some code</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>
<span class="nx">g</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]()</span> <span class="o">===</span> <span class="nx">g</span>
<span class="c1">// true</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">true</span>
</pre></div>
</div>
<p>上面代码中，gen是一个Generator函数，调用它会生成一个遍历器对象g。它的Symbol.iterator属性，也是一个遍历器对象生成函数，执行后返回它自己。</p>
<div class="section" id="next">
<span id="next"></span><h2>next方法的参数<a class="headerlink" href="#next" title="永久链接至标题">¶</a></h2>
<p>yield句本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield语句的返回值。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="kc">true</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">reset</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">i</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">reset</span><span class="p">)</span> <span class="p">{</span> <span class="nx">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">f</span><span class="p">();</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">())</span> <span class="c1">// { value: 0, done: false }</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">())</span> <span class="c1">// { value: 1, done: false }</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="kc">true</span><span class="p">))</span> <span class="c1">// { value: 0, done: false }</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">done</span><span class="p">:</span> <span class="n">false</span> <span class="p">}</span>
<span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">done</span><span class="p">:</span> <span class="n">false</span> <span class="p">}</span>
<span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">done</span><span class="p">:</span> <span class="n">false</span> <span class="p">}</span>





<span class="n">undefined</span>
</pre></div>
</div>
<p>上面代码先定义了一个可以无限运行的Generator函数f，如果next方法没有参数，每次运行到yield语句，变量reset的值总是undefined。当next方法带一个参数true时，当前的变量reset就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增。</p>
<p>这个功能有很重要的语法意义。Generator函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过next方法的参数，就有办法在Generator函数开始运行之后，继续向函数体内部注入值。也就是说，可以在Generator函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="k">yield</span> <span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
  <span class="kd">var</span> <span class="nx">z</span> <span class="o">=</span> <span class="k">yield</span> <span class="p">(</span><span class="nx">y</span> <span class="o">/</span> <span class="mi">3</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">z</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">next</span><span class="p">())</span> <span class="c1">// Object{value:6, done:false}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">next</span><span class="p">())</span> <span class="c1">// Object{value:NaN, done:false}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">next</span><span class="p">())</span> <span class="c1">// Object{value:NaN, done:true}</span>

<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">next</span><span class="p">())</span> <span class="c1">// { value:6, done:false }</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="mi">12</span><span class="p">))</span> <span class="c1">// { value:8, done:false }</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="mi">13</span><span class="p">))</span> <span class="c1">// { value:42, done:true }</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="n">done</span><span class="p">:</span> <span class="n">false</span> <span class="p">}</span>
<span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="n">NaN</span><span class="p">,</span> <span class="n">done</span><span class="p">:</span> <span class="n">false</span> <span class="p">}</span>
<span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="n">NaN</span><span class="p">,</span> <span class="n">done</span><span class="p">:</span> <span class="n">true</span> <span class="p">}</span>
<span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="n">done</span><span class="p">:</span> <span class="n">false</span> <span class="p">}</span>
<span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="n">done</span><span class="p">:</span> <span class="n">false</span> <span class="p">}</span>
<span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="mi">42</span><span class="p">,</span> <span class="n">done</span><span class="p">:</span> <span class="n">true</span> <span class="p">}</span>





<span class="n">undefined</span>
</pre></div>
</div>
<p>上面代码中，第二次运行next方法的时候不带参数，导致y的值等于2 * undefined（即NaN），除以3以后还是NaN，因此返回对象的value属性也等于NaN。第三次运行Next方法的时候不带参数，所以z等于undefined，返回对象的value属性等于5 + NaN + undefined，即NaN。</p>
<p>如果向next方法提供参数，返回结果就完全不一样了。上面代码第一次调用b的next方法时，返回x+1的值6；第二次调用next方法，将上一次yield语句的值设为12，因此y等于24，返回y / 3的值8；第三次调用next方法，将上一次yield语句的值设为13，因此z等于13，这时x等于5，y等于24，所以return语句的值等于42。</p>
<p><strong>注意，由于next方法的参数表示上一个yield语句的返回值，所以第一次使用next方法时，不能带有参数。V8引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。</strong></p>
<p>如果想要第一次调用next方法时，就能够输入值，可以在Generator函数外面再包一层。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">wrapper</span><span class="p">(</span><span class="nx">generatorFunction</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">generatorObject</span> <span class="o">=</span> <span class="nx">generatorFunction</span><span class="p">(...</span><span class="nx">args</span><span class="p">);</span>
    <span class="nx">generatorObject</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
    <span class="k">return</span> <span class="nx">generatorObject</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">wrapped</span> <span class="o">=</span> <span class="nx">wrapper</span><span class="p">(</span><span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`First input: </span><span class="si">${</span><span class="k">yield</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
  <span class="k">return</span> <span class="s1">&#39;DONE&#39;</span><span class="p">;</span>
<span class="p">});</span>

<span class="nx">wrapped</span><span class="p">().</span><span class="nx">next</span><span class="p">(</span><span class="s1">&#39;hello!&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>First input: hello!





{ value: &#39;DONE&#39;, done: true }
</pre></div>
</div>
<p>上面代码中，Generator函数如果不用wrapper先包一层，是无法第一次调用next方法，就输入参数的。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">dataConsumer</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Started&#39;</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`1. </span><span class="si">${</span><span class="k">yield</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`2. </span><span class="si">${</span><span class="k">yield</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
  <span class="k">return</span> <span class="s1">&#39;result&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">genObj</span> <span class="o">=</span> <span class="nx">dataConsumer</span><span class="p">();</span>
<span class="nx">genObj</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
<span class="c1">// Started</span>
<span class="nx">genObj</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="c1">// 1. a</span>
<span class="nx">genObj</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="c1">// 2. b</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>Started
1. a
2. b





{ value: &#39;result&#39;, done: true }
</pre></div>
</div>
<p>上面代码是一个很直观的例子，每次通过next方法向Generator函数输入值，然后打印出来。</p>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="../_sources/ES6语法/生成器对象.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; 版权所有 2016, hsz.<br/>
      由 <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.5 创建。<br/>
    </p>
  </div>
</footer>
  </body>
</html>