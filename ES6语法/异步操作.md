
python是默认的全同步实现,它的异步都是通过框架实现的,比如gevent,tornad,在3.4之后python加入了async标准包实现了语言级别的异步,但貌似买帐的人不多,也算是历史遗留问题了.

所谓"异步"，简单说就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。

比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。

相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。

Js没有这些包袱,所以在异步方案方便确实做得比python好,js中异步处理并发主要手段是:

+ 回调函数与Event对象

+ Promise对象

+ 生成器与协程


# 回调函数与Event对象

这是最原始也是最好理解的手段,所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。它的英语名字callback，直译过来就是"重新调用"。python中的tornado就是异步回调实现的服务器

在js中这是非常常见的技术,比如读取一个文件:


```javascript
import * as fs from "fs"
```




    'use strict'




```javascript
import 'babel-polyfill'
```




    {}




```javascript
fs.readFile('./README.md', 'utf-8',function (err, data) {
  if (err) throw err
  console.log(data.slice(0,20))
})
```




    undefined



    # ES6快速入门
    
    本文主要是为已经学


上面代码中，readFile函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了`./README.md`这个文件以后，回调函数才会执行。

一个有趣的问题是，为什么Node.js约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是null）？原因是执行分成两段，在这两段之间抛出的错误，程序无法捕捉，只能当作参数，传入第二段。

## Event对象

Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态。

事件通常与回调函数结合使用,这与tkinter中类似

这边我们只讲html中的标准Eventapi

### 事件句柄　(Event Handlers)

HTML事件触发浏览器中的行为，比如当用户点击某个 HTML 元素时启动一段 JavaScript。下面是一个属性列表，可将之插入 HTML 标签以定义事件的行为。
属性	|此事件发生在何时
---|---
onabort	|图像的加载被中断。
onblur	|元素失去焦点。
onchange	|域的内容被改变。
onclick	|当用户点击某个对象时调用的事件句柄。
ondblclick	|当用户双击某个对象时调用的事件句柄。
onerror	|在加载文档或图像时发生错误。
onfocus|	元素获得焦点。
onkeydown	|某个键盘按键被按下。
onkeypress	|某个键盘按键被按下并松开。
onkeyup	|某个键盘按键被松开。
onload	|一张页面或一幅图像完成加载。
onmousedown|	鼠标按钮被按下。
onmousemove|	鼠标被移动。
onmouseout|	鼠标从某元素移开。
onmouseover|	鼠标移到某元素之上。
onmouseup	|鼠标按键被松开。
onreset	|重置按钮被点击。
onresize	|窗口或框架被重新调整大小。
onselect	|文本被选中。
onsubmit	|确认按钮被点击。
onunload	|用户退出页面。


### 鼠标 / 键盘属性

属性	|描述
---|---
altKey	|返回当事件被触发时，"ALT" 是否被按下。
button	|返回当事件被触发时，哪个鼠标按钮被点击。
clientX	|返回当事件被触发时，鼠标指针的水平坐标。
clientY	|返回当事件被触发时，鼠标指针的垂直坐标。
ctrlKey|	返回当事件被触发时，"CTRL" 键是否被按下。
metaKey	|返回当事件被触发时，"meta" 键是否被按下。
relatedTarget	|返回与事件的目标节点相关的节点。
screenX	|返回当某个事件被触发时，鼠标指针的水平坐标。
screenY	|返回当某个事件被触发时，鼠标指针的垂直坐标。
shiftKey	|返回当事件被触发时，"SHIFT" 键是否被按下。


### 标准 Event 属性

下面列出了 2 级 DOM 事件标准定义的属性。

属性	|描述
---|---
bubbles	|返回布尔值，指示事件是否是起泡事件类型。
cancelable	|返回布尔值，指示事件是否可拥可取消的默认动作。
currentTarget	|返回其事件监听器触发该事件的元素。
eventPhase	|返回事件传播的当前阶段。
target	|返回触发此事件的元素（事件的目标节点）。
timeStamp	|返回事件生成的日期和时间。
type	|返回当前 Event 对象表示的事件的名称。

### 标准 Event 方法

下面列出了 2 级 DOM 事件标准定义的方法。IE 的事件模型不支持这些方法：

方法	|描述
---|---
initEvent()	|初始化新创建的 Event 对象的属性。
preventDefault()	|通知浏览器不要执行与事件关联的默认动作。
stopPropagation()	|不再派发事件。


## 回调的缺点

回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下

```js
fs.readFile(fileA, function (err, data) {
  fs.readFile(fileB, function (err, data) {
    // ...
  })
})
```

如果依次读取多个文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。这种情况就称为"回调函数噩梦"（callback hell）

# Promise

promise翻译成中文就是保证,是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。

所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise是一个对象，从它可以获取异步操作的消息。Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。

Promise对象有以下两个特点。

1. 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。

2. 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。

有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。

Promise也有一些缺点:

+ 无法取消Promise，一旦新建它就会立即执行，无法中途取消。
+ 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。
+ 当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。

如果某些事件不断地反复发生，一般来说，使用stream模式(生成器)是比部署Promise更好的选择。

## 基本用法

Promise对象是一个构造函数，参数是一个函数对象,用来生成Promise实例

```js
var promise = new Promise(function(resolve, reject) {
  // ... some code

  if (/* 异步操作成功 */){
    resolve(value)
  } else {
    reject(error)
  }
})

```

Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由JavaScript引擎提供，不用自己部署。


+ resolve函数

    将Promise对象的状态从“未完成”变为“成功”（即从Pending变为Resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去
    
+ reject函数

    将Promise对象的状态从“未完成”变为“失败”（即从Pending变为Rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。

Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数。

```js
promise.then(function(value) {
  // success
}, function(value) {
  // failure
});
```

then方法可以接受两个回调函数作为参数。

+ 第一个回调函数是Promise对象的状态变为Resolved时调用
+ 第二个回调函数是Promise对象的状态变为Reject时调用。

其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。



>一个简单的例子


```javascript
function timeout(ms) {
  return new Promise((resolve, reject) => {
    setTimeout(resolve, ms, 'done')
  })
}

timeout(100).then((value) => {
  console.log(value)
})
```




    Promise { <pending> }



    done


上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为Resolved，就会触发then方法绑定的回调函数。

Promise新建后就会立即执行。

> 异步实现


```javascript
let promise = new Promise(function(resolve, reject) {
  console.log('1')
  resolve()
})

promise.then(function() {
  console.log('2.')
})

console.log('3')

```

    1
    3





    undefined



    2.


可以看到实际上异步主要就是在then上实现了

### 异步实现图片加载


```js
function loadImageAsync(url) {
  return new Promise(function(resolve, reject) {
    var image = new Image()

    image.onload = function() {
      resolve(image)
    }

    image.onerror = function() {
      reject(new Error('Could not load image at ' + url))
    }

    image.src = url
  })
}
```


```javascript
loadImageAsync('./source/jsextend.png')
```




    Promise { <rejected> [ReferenceError: Image is not defined] }



### ajax操作

```js
var getJSON = function(url) {
  var promise = new Promise(function(resolve, reject){
    var client = new XMLHttpRequest()
    client.open("GET", url)
    client.onreadystatechange = handler
    client.responseType = "json"
    client.setRequestHeader("Accept", "application/json")
    client.send()

    function handler() {
      if ( this.readyState !== 4 ) {
        return
      }
      if (this.status === 200) {
        resolve(this.response)
      } else {
        reject(new Error(this.statusText))
      }
    }
  })

  return promise
}

getJSON("/posts.json").then(function(json) {
  console.log('Contents: ' + json)
}, function(error) {
  console.error('出错了', error)
})
```

getJSON是对XMLHttpRequest对象的封装，用于发出一个针对JSON数据的HTTP请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。

如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误


resolve函数的参数除了正常的值以外，还可能是另一个Promise实例，表示异步操作的结果有可能是一个值，也有可能是另一个异步操作


```javascript
var p1 = new Promise(function (resolve, reject) {
  setTimeout(() => {
      reject(new Error('fail'))
  }, 3000)
})
var p2 = new Promise(function (resolve, reject) {
  setTimeout(() => {
      resolve(p1)
  }, 1000)
})
p2.then(result => console.log(result))
p2.catch(error => console.log(error))
```




    Promise { <pending> }



    [Error: fail]


上面代码中，p1是一个Promise，3秒之后变为rejected。p2的状态由p1决定，1秒之后，p2调用resolve方法，但是此时p1的状态还没有改变，因此p2的状态也不会变。又过了2秒，p1变为rejected，p2也跟着变为rejected。

## 实例方法then() 

Promise实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为Promise实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。

then方法返回的是一个**新的Promise实例**（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。

```js
getJSON("/posts.json").then(function(json) {
  return json.post
}).then(function(post) {
  // ...
})
```

上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。

采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。

```js
getJSON("/post/1.json").then(function(post) {
  return getJSON(post.commentURL)
}).then(function funcA(comments) {
  console.log("Resolved: ", comments)
}, function funcB(err){
  console.log("Rejected: ", err)
})
```

上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为Resolved，就调用funcA，如果状态变为Rejected，就调用funcB。

如果采用箭头函数，上面的代码可以写得更简洁。

```js
getJSON("/post/1.json").then(
  post => getJSON(post.commentURL)
).then(
  comments => console.log("Resolved: ", comments),
  err => console.log("Rejected: ", err)
)
```

## Promise对象的catch()
catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。

```js
getJSON("/posts.json").then(function(posts) {
  // ...
}).catch(function(error) {
  // 处理 getJSON 和 前一个回调函数运行时发生的错误
  console.log('发生错误！', error)
})
```

上面代码中，getJSON方法返回一个Promise对象，如果该对象状态变为Resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为Rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。

```js
p.then((val) => console.log("fulfilled:", val))
  .catch((err) => console.log("rejected:", err));

// 等同于

p.then((val) => console.log(fulfilled:", val))
  .then(null, (err) => console.log("rejected:", err))
```

下面是一个例子。



```javascript
var promise = new Promise(function(resolve, reject) {
  throw new Error('test')
})
promise.catch(error => {
  console.log(error)
})
```




    Promise { <pending> }



    [Error: test]


上面代码中，promise抛出一个错误，就被catch方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。


```javascript
var promise = new Promise(function(resolve, reject) {
  try {
    throw new Error('test')
  } catch(e) {
    reject(e)
  }
})
promise.catch(function(error) {
  console.log(error)
})
```




    Promise { <pending> }



    [Error: test]



```javascript
var promise = new Promise(function(resolve, reject) {
  reject(new Error('test'))
})
promise.catch(function(error) {
  console.log(error)
})
```




    Promise { <pending> }



    [Error: test]


比较上面两种写法，可以发现reject方法的作用，等同于抛出错误。
如果Promise状态已经变成Resolved，再抛出错误是无效的。


```javascript
var promise = new Promise(function(resolve, reject) {
  resolve('ok')
  throw new Error('test')
})
promise.then(value => { console.log(value) })
       .catch(error => { console.log(error) })
```




    Promise { <pending> }



    ok


上面代码中，Promise在resolve语句后面，再抛出错误，不会被捕获，等于没有抛出。

Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。

```js
getJSON("/post/1.json").then(function(post) {
  return getJSON(post.commentURL);
}).then(function(comments) {
  // some code
}).catch(function(error) {
  // 处理前面三个Promise产生的错误
})
```

上面代码中，一共有三个Promise对象：一个由getJSON产生，两个由then产生。它们之中任何一个抛出的错误，都会被最后一个catch捕获。

一般来说，不要在then方法里面定义Reject状态的回调函数（即then的第二个参数），总是使用catch方法。这种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用catch方法，而不使用then方法的第二个参数。

跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。


```javascript
var someAsyncThing = function() {
  return new Promise(function(resolve, reject) {
    // 下面一行会报错，因为x没有声明
    resolve(x + 2)
  })
}

someAsyncThing().then(function() {
  console.log('everything is great')
})
```




    Promise { <pending> }



上面代码中，someAsyncThing函数产生的Promise对象会报错，但是由于没有指定catch方法，这个错误不会被捕获，也不会传递到外层代码，导致运行后没有任何输出。注意，Chrome浏览器不遵守这条规定，它会抛出错误“ReferenceError: x is not defined”。


```javascript
var promise = new Promise(function(resolve, reject) {
  resolve("ok")
  setTimeout(function() { throw new Error('test') }, 0)
})
promise.then(function(value) { console.log(value) })
```




    Promise { <pending> }



    ok


    Error: test
        at null._onTimeout (evalmachine.<anonymous>:6:11)
        at Timer.listOnTimeout (timers.js:92:15)


上面代码中，Promise指定在下一轮“事件循环”再抛出错误，结果由于没有指定使用try...catch语句，就冒泡到最外层，成了未捕获的错误。因为此时，Promise的函数体已经运行结束了，所以这个错误是在Promise函数体外抛出的。

Node.js有一个unhandledRejection事件，专门监听未捕获的reject错误。


```javascript
var someAsyncThing = function() {
  return new Promise(function(resolve, reject) {
    // 下面一行会报错，因为x没有声明
    resolve(x + 2)
  })
}

someAsyncThing()
.catch(function(error) {
  console.log('oh no', error)
})
.then(function() {
  console.log('carry on')
});
```




    Promise { <pending> }



    oh no [ReferenceError: x is not defined]
    carry on


上面代码运行完catch方法指定的回调函数，会接着运行后面那个then方法指定的回调函数。如果没有报错，则会跳过catch方法。


```javascript
Promise.resolve()
.catch(function(error) {
  console.log('oh no', error);
})
.then(function() {
  console.log('carry on');
})
```




    Promise { <pending> }



    carry on


上面的代码因为没有报错，跳过了catch方法，直接执行后面的then方法。此时，要是then方法里面报错，就与前面的catch无关了。

catch方法之中，还能再抛出错误。


```javascript
var someAsyncThing = function() {
  return new Promise(function(resolve, reject) {
    // 下面一行会报错，因为x没有声明
    resolve(x + 2)
  })
}

someAsyncThing().then(function() {
  return someOtherAsyncThing()
}).catch(function(error) {
  console.log('oh no', error)
  // 下面一行会报错，因为y没有声明
  y + 2;
}).then(function() {
  console.log('carry on')
})
```




    Promise { <pending> }



    oh no [ReferenceError: x is not defined]


    ReferenceError: y is not defined
        at evalmachine.<anonymous>:15:3
        at runMicrotasksCallback (node.js:326:7)
        at doNTCallback0 (node.js:419:9)
        at process._tickCallback (node.js:348:13)


上面代码中，catch方法抛出一个错误，因为后面没有别的catch方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。


```javascript
someAsyncThing().then(function() {
  return someOtherAsyncThing();
}).catch(function(error) {
  console.log('oh no', error);
  // 下面一行会报错，因为y没有声明
  y + 2;
}).catch(function(error) {
  console.log('carry on', error);
});

```




    Promise { <pending> }



    oh no [ReferenceError: x is not defined]
    carry on [ReferenceError: y is not defined]


上面代码中，第二个catch方法用来捕获，前一个catch方法抛出的错误。

## Promise.all()

Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。

    var p = Promise.all([p1, p2, p3])
    
上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是Promise对象的实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例。）

p的状态由p1、p2、p3决定，分成两种情况。

+ 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。

+ 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。


```js
var promises = [2, 3, 5, 7, 11, 13].map(function (id) {
  return getJSON("/post/" + id + ".json")
})

Promise.all(promises).then(function (posts) {
  // ...
}).catch(function(reason){
  // ...
})
```

上面代码中，promises是包含6个Promise实例的数组，只有这6个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。

下面是另一个例子。

```js
const databasePromise = connectDatabase()

const booksPromise = databaseProimse
  .then(findAllBooks)

const userPromise = databasePromise
  .then(getCurrentUser)

Promise.all([
  booksPromise,
  userPromise
])
.then(([books, user]) => pickTopRecommentations(books, user))

```

上面代码中，booksPromise和userPromise是两个异步操作，只有等到它们的结果都返回了，才会触发pickTopRecommentations这个回调函数。

## Promise.race()

Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。

    var p = Promise.race([p1,p2,p3])
    
上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的回调函数。

Promise.race方法的参数与Promise.all方法一样，如果不是Promise实例，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。

下面是一个例子，如果指定时间内没有获得结果，就将Promise的状态变为reject，否则变为resolve。

```js
var p = Promise.race([
  fetch('/resource-that-may-take-a-while'),
  new Promise(function (resolve, reject) {
    setTimeout(() => reject(new Error('request timeout')), 5000)
  })
])
p.then(response => console.log(response))
p.catch(error => console.log(error))
```

上面代码中，如果5秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。

## Promise.resolve()

有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。

```js
var jsPromise = Promise.resolve($.ajax('/whatever.json'))
```

上面代码将jQuery生成的deferred对象，转为一个新的Promise对象。

Promise.resolve等价于下面的写法。

```js
Promise.resolve('foo')
// 等价于
new Promise(resolve => resolve('foo'))
Promise.resolve方法的参数分成四种情况。
```

1. 参数是一个Promise实例

    如果参数是Promise实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。

2. 参数是一个thenable对象

    thenable对象指的是具有then方法的对象，比如下面这个对象。

    ```js
    let thenable = {
      then: function(resolve, reject) {
        resolve(42)
      }
    }
    ```

    Promise.resolve方法会将这个对象转为Promise对象，然后就立即执行thenable对象的then方法。

    ```
    let thenable = {
      then: function(resolve, reject) {
        resolve(42)
      }
    }

    let p1 = Promise.resolve(thenable);
    p1.then(function(value) {
      console.log(value)  // 42
    })
    ```

    上面代码中，thenable对象的then方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then方法指定的回调函数，输出42。

3. 参数不是具有then方法的对象，或根本就不是对象

    如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为Resolved。


```javascript
var p = Promise.resolve('Hello');

p.then(function (s){
  console.log(s)
})
```




    Promise { <pending> }



    Hello


// Hello
上面代码生成一个新的Promise对象的实例p。由于字符串Hello不属于异步操作（判断方法是它不是具有then方法的对象），返回Promise实例的状态从一生成就是Resolved，所以回调函数会立即执行。Promise.resolve方法的参数，会同时传给回调函数。

4.不带有任何参数

Promise.resolve方法允许调用时不带参数，直接返回一个Resolved状态的Promise对象。

所以，如果希望得到一个Promise对象，比较方便的方法就是直接调用Promise.resolve方法。

```js
var p = Promise.resolve()

p.then(function () {
  // ...
})
```
上面代码的变量p就是一个Promise对象。

## Promise.reject()

Promise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected。它的参数用法与Promise.resolve方法完全一致。

```js
var p = Promise.reject('出错了');
// 等同于
var p = new Promise((resolve, reject) => reject('出错了'))

p.then(null, function (s){
  console.log(s)
});
// 出错了
```

上面代码生成一个Promise对象的实例p，状态为rejected，回调函数会立即执行。

## 两个有用的附加方法

ES6的Promise API提供的方法不是很多，有些有用的方法可以自己部署。下面介绍如何部署两个不在ES6之中、但很有用的方法。

### done()
Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。

```js
asyncFunc()
  .then(f1)
  .catch(r1)
  .then(f2)
  .done()
```

它的实现代码相当简单。

```js
Promise.prototype.done = function (onFulfilled, onRejected) {
  this.then(onFulfilled, onRejected)
    .catch(function (reason) {
      // 抛出一个全局错误
      setTimeout(() => { throw reason }, 0)
    })
}
```

从上面代码可见，done方法的使用，可以像then方法那样用，提供Fulfilled和Rejected状态的回调函数，也可以不提供任何参数。但不管怎样，done都会捕捉到任何可能出现的错误，并向全局抛出。

### finally()

finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。

下面是一个例子，服务器使用Promise处理请求，然后使用finally方法关掉服务器。

```js
server.listen(0)
  .then(function () {
    // run test
  })
  .finally(server.stop)
```
它的实现也很简单。

```js
Promise.prototype.finally = function (callback) {
  let P = this.constructor
  return this.then(
    value  => P.resolve(callback()).then(() => value),
    reason => P.resolve(callback()).then(() => { throw reason })
  )
}
```
上面代码中，不管前面的Promise是fulfilled还是rejected，都会执行回调函数callback。

## 如何理解Promise

Promise其实可以理解为规划,如果说回调是面向对象的,那Promise就是面向全局的,它把每种可能都描述在一起,而不是分开来给不同的地方


# 生成器与协程

传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做"协程"（coroutine），意思是多个线程互相协作，完成异步任务。

协程有点像函数，又有点像线程。它的运行流程大致如下。

第一步，协程A开始执行。

第二步，协程A执行到一半，进入暂停，执行权转移到协程B。

第三步，（一段时间后）协程B交还执行权。

第四步，协程A恢复执行。

上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。

举例来说，读取文件的协程写法如下。

```js
function *asnycJob() {
  // ...其他代码
  var f = yield readFile(fileA);
  // ...其他代码
}
```

上面代码的函数asyncJob是一个协程，它的奥妙就在其中的yield命令。它表示执行到此处，执行权将交给其他协程。也就是说，yield命令是异步两个阶段的分界线。

协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。

Generator函数是协程在ES6的实现，最大特点就是可以交出函数的执行权（即暂停执行）。

整个Generator函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。Generator函数的执行方法如下。

```js

function* gen(x){
  var y = yield x + 2;
  return y;
}

var g = gen(1);
g.next() // { value: 3, done: false }
g.next() // { value: undefined, done: true }
```

上面代码中，调用Generator函数，会返回一个内部指针（即遍历器）g 。这是Generator函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针g的next方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的yield语句，上例是执行到x + 2为止。

换言之，next方法的作用是分阶段执行Generator函数。每次调用next方法，会返回一个对象，表示当前阶段的信息（value属性和done属性）。value属性是yield语句后面表达式的值，表示当前阶段的值；done属性是一个布尔值，表示Generator函数是否执行完毕，即是否还有下一个阶段。



## Generator函数的数据交换和错误处理

Generator函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。

next方法返回值的value属性，是Generator函数向外输出数据；next方法还可以接受参数，这是向Generator函数体内输入数据。




```javascript
function* gen(x){
  var y = yield x + 2;
  return y;
}

var g = gen(1);
console.log(g.next()) // { value: 3, done: false }
console.log(g.next(2)) // { value: 2, done: true }
```

    { value: 3, done: false }
    { value: 2, done: true }





    undefined



上面代码中，第一个next方法的value属性，返回表达式x + 2的值（3）。第二个next方法带有参数2，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量y接收。因此，这一步的 value 属性，返回的就是2（变量y的值）。

Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。


```javascript
function* gen(x){
  try {
    var y = yield x + 2;
  } catch (e){
    console.log(e);
  }
  return y;
}

var g = gen(1);
g.next();
g.throw('出错了');
// 出错了

```

    出错了





    { value: undefined, done: true }



上面代码的最后一行，Generator函数体外，使用指针对象的throw方法抛出的错误，可以被函数体内的try ...catch代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。

## 异步任务的封装
下面看看如何使用 Generator 函数，执行一个真实的异步任务。


```javascript
import fetch from 'node-fetch'
function* gen(){
  var url = 'https://api.github.com/users/github'
  var result = yield fetch(url)
  console.log(result.bio)
}
```




    'use strict'



执行


```javascript
var g = gen()
var result = g.next()

result.value.then(function(data){
  return data.json()
}).then(function(data){
  g.next(data)
})
```




    Promise {
      _c: [],
      _a: undefined,
      _s: 0,
      _d: false,
      _v: undefined,
      _h: 0,
      _n: false }



    How people build software.




上面代码中，Generator函数封装了一个异步操作，该操作先读取一个远程接口，然后从JSON格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了yield命令。

上面代码中，首先执行Generator函数，获取遍历器对象，然后使用next 方法（第二行），执行异步任务的第一阶段。由于Fetch模块返回的是一个Promise对象，因此要用then方法调用下一个next 方法。

可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。

## Thunk函数

参数的求值策略
Thunk函数早在上个世纪60年代就诞生了。

那时，编程语言刚刚起步，计算机学家还在研究，编译器怎么写比较好。一个争论的焦点是"求值策略"，即函数的参数到底应该何时求值

+ 一种意见是"传值调用"（call by value），即在进入函数体之前，就计算表达式的值，再将这个值传入函数f 。C语言就采用这种策略。

    ```
    f(x + 5)
    // 传值调用时，等同于
    f(6)
    ```
    
+ 另一种意见是"传名调用"（call by name），即直接将表达式x + 5传入函数体，只在用到它的时候求值。Haskell语言采用这种策略。

    ```
    function f(x){return x*2}
    f(x + 5)
    // 传名调用时，等同于
    (x + 5) * 2
    ```

传值调用和传名调用，哪一种比较好？回答是各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。

```
function f(a, b){
  return b;
}

f(3 * x * x - 2 * x - 1, x)
```

上面代码中，函数f的第一个参数是一个复杂的表达式，但是函数体内根本没用到。对这个参数求值，实际上是不必要的。因此，有一些计算机学家倾向于"传名调用"，即只在执行时求值。

编译器的"传名调用"实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做Thunk函数。

```js
function f(m){
  return m * 2;
}

f(x + 5);

// 等同于

var thunk = function () {
  return x + 5;
};

function f(thunk){
  return thunk() * 2;
}
```

上面代码中，函数f的参数x + 5被一个函数替换了。凡是用到原参数的地方，对Thunk函数求值即可。 这就是Thunk函数的定义，它是"传名调用"的一种实现策略，用来替换某个表达式。

### JavaScript语言的Thunk函数

JavaScript语言是传值调用，它的Thunk函数含义有所不同。在JavaScript语言中，Thunk函数替换的不是表达式，而是多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数。

```js
// 正常版本的readFile（多参数版本）
fs.readFile(fileName, callback)

// Thunk版本的readFile（单参数版本）
var readFileThunk = Thunk(fileName)
readFileThunk(callback)

var Thunk = function (fileName){
  return function (callback){
    return fs.readFile(fileName, callback)
  }
}
```


上面代码中，fs模块的readFile方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做Thunk函数。

任何函数，只要参数有回调函数，就能写成Thunk函数的形式。下面是一个简单的Thunk函数转换器。

```js
var Thunk = function(fn){
  return function (){
    var args = Array.prototype.slice.call(arguments)
    return function (callback){
      args.push(callback)
      return fn.apply(this, args)
    }
  }
}
```

使用上面的转换器，生成fs.readFile的Thunk函数。

```js
var readFileThunk = Thunk(fs.readFile)
readFileThunk(fileA)(callback)
```

## Thunkify模块

生产环境的转换器，建议使用Thunkify模块。

首先是安装。

    npm install thunkify
    
使用方式如下。



```
var thunkify = require('thunkify');
var fs = require('fs');

var read = thunkify(fs.readFile);
read('package.json')(function(err, str){
  // ...
})

```
Thunkify的源码与上一节那个简单的转换器非常像。

```js
function thunkify(fn){
  return function(){
    var args = new Array(arguments.length)
    var ctx = this

    for(var i = 0; i < args.length; ++i) {
      args[i] = arguments[i]
    }

    return function(done){
      var called

      args.push(function(){
        if (called) return
        called = true
        done.apply(null, arguments)
      })

      try {
        fn.apply(ctx, args)
      } catch (err) {
        done(err)
      }
    }
  }
}

```

它的源码主要多了一个检查机制，变量called确保回调函数只运行一次。这样的设计与下文的Generator函数相关。请看下面的例子。

```js
function f(a, b, callback){
  var sum = a + b;
  callback(sum);
  callback(sum);
}

var ft = thunkify(f);
var print = console.log.bind(console);
ft(1, 2)(print);
// 3
```
上面代码中，由于thunkify只允许回调函数执行一次，所以只输出一行结果。

## Generator 函数的流程管理

Thunk函数有什么用？回答是以前确实没什么用，但是ES6有了Generator函数，Thunk函数现在可以用于Generator函数的自动流程管理。

以读取文件为例。下面的Generator函数封装了两个异步操作。


```javascript
import * as fs from "fs"
import thunkify from'thunkify'
    
let readFile = thunkify(fs.readFile)

let gen = function* (){
  let r1 = yield readFile('./README.md',"utf-8")
  console.log(r1.toString())
  let r2 = yield readFile('./package.json',"utf-8")
  console.log(r2.toString())
}
```




    'use strict'



上面代码中，yield命令用于将程序的执行权移出Generator函数，那么就需要一种方法，将执行权再交还给Generator函数。

这种方法就是Thunk函数，因为它可以在回调函数里，将执行权交还给Generator函数。为了便于理解，我们先看如何手动执行上面这个Generator函数


```javascript
var g = gen()

var r1 = g.next()
r1.value(function(err, data){
  if (err) throw err
  var r2 = g.next(data)
  r2.value(function(err, data){
    if (err) throw err
    g.next(data)
  })
})
```




    undefined



    # ES6快速入门
    
    本文主要是为已经学过python的人而写的攻略文,数据科学家除了要会收集分析数据,同样需要掌握一些web技术,
    这样才可以做数据可视化.Js作为web技术的标志和基础自然是不可能不学习的.直接从ES6标准入手的好处是:
    
    + 语法糖丰富
    
        低版本的Js语法简单而且坑多,使用起来各种不方便,会给习惯python的数据科学研究人员造成学习困难,
        ES6新增了大量语法糖.在使用上可以给被python惯坏了的人一定程度上减少学习成本.
    
    + 接近Python的开发习惯
    
        Python是模块化编程的语言,而Js在设计初期就没考虑太多模块化的问题,低版本的js在编写时模块化方面
        会让被python惯坏了的人非常不喜欢,ES6使用类似python的`import`语句,相对容易接受.
    
    + 可以顺利过渡学习JSX和react
    
        前端开发框架react使用组件化思路构建web前端应用,相对更加接近python等语言中编写GUI的方式,而且
        该框架比较程序员思维,类似搭积木式的编写方式也更加接近python用户习惯
    
    事实上Js语言是比python有活力的多的一门编程语言,它充分体现着开源的魅力和模块化的威力,在google v8引擎的
    性能保证下,Js语言是当今最受欢迎并且发展最快的语言没有之一,作为一个pythoner我们也确实该看看它有些什么可取之处.
    
    在后面的几部分中我们会从分以下几个步骤与python对比着快速入门ES6
    
    1. 环境与基本工具链:
    
        + node.js,npm包管理工具与babel转换器
        + 文档,代码风格检验与测试框架
        + 工作流工具链
    
    2. 基本语法
    
        + 值与运算
        + 基本容器
        + 逻辑表达式,控制结构与特殊对象Fuction
        + 生成器对象
        + 特殊对象RegExp和Date
        + 变量,声明与作用域
        + 对象,类与面向对象编程
        + 异步操作
        + 二进制数组
        + 代理与反射
        + 模块化编程
    
    3. ES7新特性
    
        + 装饰器
        
    本文主要参考自阮一峰大大的书`<ECMAScript 6 入门>`,这本书讲解ES6语法相当好,评论中也有不少有用的知识,只是ES6标准事实上
    基本上得靠babel转换器实现,而它又是一个高度模块化的项目,加上js资源非常丰富,同样的功能有大量的实现,部署环境就已经是一个非
    常不容易的工程了,相比而言反而ES6语法部分学起来反而没啥太大难度.简单说就是这本书并不适用于我所面向的对象.所以只能在大量参
    考的基础上加上具体的使用方式和环境配置方面的文字了.
    {
      "name": "quick_start",
      "version": "1.0.0",
      "description": "ES6快速入门",
      "main": "index.js",
      "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1"
      },
      "author": "",
      "license": "ISC",
      "devDependencies": {
        "babel-cli": "^6.7.5",
        "babel-core": "^6.7.6",
        "babel-plugin-syntax-decorators": "^6.3.13",
        "babel-plugin-transform-decorators-legacy": "^1.3.4",
        "babel-plugin-transform-runtime": "^6.7.5",
        "babel-polyfill": "^6.7.4",
        "babel-preset-es2015": "^6.6.0",
        "babel-preset-stage-0": "^6.5.0",
        "babel-preset-stage-1": "^6.5.0",
        "babel-preset-stage-2": "^6.5.0",
        "babel-preset-stage-3": "^6.5.0",
        "babel-register": "^6.7.2",
        "eslint": "^2.7.0",
        "node-fetch": "^1.5.1",
        "thunkify": "^2.1.2"
      },
      "babel": {
        "presets": [
          "es2015",
          "stage-0"
        ],
        "plugins": [
          "syntax-decorators",
          "transform-runtime"
        ]
      },
      "dependencies": {
        "babel-runtime": "^6.6.1"
      }
    }
    


上面代码中，变量g是Generator函数的内部指针，表示目前执行到哪一步。next方法负责将指针移动到下一步，并返回该步的信息（value属性和done属性）。

仔细查看上面的代码，可以发现Generator函数的执行过程，其实是将同一个回调函数，反复传入next方法的value属性。这使得我们可以用递归来自动完成这个过程。

## Thunk函数的自动流程管理

Thunk函数真正的威力，在于可以自动执行Generator函数。下面就是一个基于Thunk函数的Generator执行器。


```javascript
function run(fn) {
  let gen = fn()

  function next(err, data) {
    let result = gen.next(data)
    if (result.done) return
    result.value(next)
  }

  next()
}

run(gen)
```




    undefined



    # ES6快速入门
    
    本文主要是为已经学过python的人而写的攻略文,数据科学家除了要会收集分析数据,同样需要掌握一些web技术,
    这样才可以做数据可视化.Js作为web技术的标志和基础自然是不可能不学习的.直接从ES6标准入手的好处是:
    
    + 语法糖丰富
    
        低版本的Js语法简单而且坑多,使用起来各种不方便,会给习惯python的数据科学研究人员造成学习困难,
        ES6新增了大量语法糖.在使用上可以给被python惯坏了的人一定程度上减少学习成本.
    
    + 接近Python的开发习惯
    
        Python是模块化编程的语言,而Js在设计初期就没考虑太多模块化的问题,低版本的js在编写时模块化方面
        会让被python惯坏了的人非常不喜欢,ES6使用类似python的`import`语句,相对容易接受.
    
    + 可以顺利过渡学习JSX和react
    
        前端开发框架react使用组件化思路构建web前端应用,相对更加接近python等语言中编写GUI的方式,而且
        该框架比较程序员思维,类似搭积木式的编写方式也更加接近python用户习惯
    
    事实上Js语言是比python有活力的多的一门编程语言,它充分体现着开源的魅力和模块化的威力,在google v8引擎的
    性能保证下,Js语言是当今最受欢迎并且发展最快的语言没有之一,作为一个pythoner我们也确实该看看它有些什么可取之处.
    
    在后面的几部分中我们会从分以下几个步骤与python对比着快速入门ES6
    
    1. 环境与基本工具链:
    
        + node.js,npm包管理工具与babel转换器
        + 文档,代码风格检验与测试框架
        + 工作流工具链
    
    2. 基本语法
    
        + 值与运算
        + 基本容器
        + 逻辑表达式,控制结构与特殊对象Fuction
        + 生成器对象
        + 特殊对象RegExp和Date
        + 变量,声明与作用域
        + 对象,类与面向对象编程
        + 异步操作
        + 二进制数组
        + 代理与反射
        + 模块化编程
    
    3. ES7新特性
    
        + 装饰器
        
    本文主要参考自阮一峰大大的书`<ECMAScript 6 入门>`,这本书讲解ES6语法相当好,评论中也有不少有用的知识,只是ES6标准事实上
    基本上得靠babel转换器实现,而它又是一个高度模块化的项目,加上js资源非常丰富,同样的功能有大量的实现,部署环境就已经是一个非
    常不容易的工程了,相比而言反而ES6语法部分学起来反而没啥太大难度.简单说就是这本书并不适用于我所面向的对象.所以只能在大量参
    考的基础上加上具体的使用方式和环境配置方面的文字了.
    {
      "name": "quick_start",
      "version": "1.0.0",
      "description": "ES6快速入门",
      "main": "index.js",
      "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1"
      },
      "author": "",
      "license": "ISC",
      "devDependencies": {
        "babel-cli": "^6.7.5",
        "babel-core": "^6.7.6",
        "babel-plugin-syntax-decorators": "^6.3.13",
        "babel-plugin-transform-decorators-legacy": "^1.3.4",
        "babel-plugin-transform-runtime": "^6.7.5",
        "babel-polyfill": "^6.7.4",
        "babel-preset-es2015": "^6.6.0",
        "babel-preset-stage-0": "^6.5.0",
        "babel-preset-stage-1": "^6.5.0",
        "babel-preset-stage-2": "^6.5.0",
        "babel-preset-stage-3": "^6.5.0",
        "babel-register": "^6.7.2",
        "eslint": "^2.7.0",
        "node-fetch": "^1.5.1",
        "thunkify": "^2.1.2"
      },
      "babel": {
        "presets": [
          "es2015",
          "stage-0"
        ],
        "plugins": [
          "syntax-decorators",
          "transform-runtime"
        ]
      },
      "dependencies": {
        "babel-runtime": "^6.6.1"
      }
    }
    


上面代码的run函数，就是一个Generator函数的自动执行器。内部的next函数就是Thunk的回调函数。next函数先将指针移到Generator函数的下一步（gen.next方法），然后判断Generator函数是否结束（result.done 属性），如果没结束，就将next函数再传入Thunk函数（result.value属性），否则就直接退出。

有了这个执行器，执行Generator函数方便多了。不管有多少个异步操作，直接传入run函数即可。当然，前提是每一个异步操作，都要是Thunk函数，也就是说，跟在yield命令后面的必须是Thunk函数。


```javascript
var gen = function* (){
  var f1 = yield readFile('./README.md')
  var f2 = yield readFile('./package.json')
}

run(gen)
```




    undefined



上面代码中，函数gen封装了n个异步的读取文件操作，只要执行run函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。

Thunk函数并不是Generator函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制Generator函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。

## co模块


co模块是著名程序员TJ Holowaychuk于2013年6月发布的一个小工具，用于Generator函数的自动执行。

比如，有一个Generator函数，用于依次读取两个文件。

```js
var gen = function* (){
  var f1 = yield readFile('/etc/fstab')
  var f2 = yield readFile('/etc/shells')
  console.log(f1.toString())
  console.log(f2.toString())
};
```
co模块可以让你不用编写Generator函数的执行器。

```js
var co = require('co')
co(gen)
```

上面代码中，Generator函数只要传入co函数，就会自动执行。

co函数返回一个Promise对象，因此可以用then方法添加回调函数。

```js
co(gen).then(function (){
  console.log('Generator 函数执行完成');
})
```

上面代码中，等到Generator函数执行结束，就会输出一行提示。

co模块的原理
为什么co可以自动执行Generator函数？

前面说过，Generator就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。

两种方法可以做到这一点:

+ 回调函数。将异步操作包装成Thunk函数，在回调函数里面交回执行权。

+ Promise 对象。将异步操作包装成Promise对象，用then方法交回执行权。


co模块其实就是将两种自动执行器（Thunk函数和Promise对象），包装成一个模块。使用co的前提条件是，Generator函数的yield命令后面，只能是Thunk函数或Promise对象。

上面已经介绍了基于Thunk函数的自动执行器。下面来看，基于Promise对象的自动执行器。这是理解co模块必须的。

基于Promise对象的自动执行
还是沿用上面的例子。首先，把fs模块的readFile方法包装成一个Promise对象。


```javascript
var readFile = function (fileName){
  return new Promise(function (resolve, reject){
    fs.readFile(fileName, function(error, data){
      if (error) reject(error)
      resolve(data)
    })
  })
}

var gen = function* (){
  var f1 = yield readFile('./README.md')
  var f2 = yield readFile('./package.json')
  console.log(f1.toString())
  console.log(f2.toString())
}
```




    'use strict'



然后，手动执行上面的Generator函数。


```javascript
var g = gen();

g.next().value.then(function(data){
  g.next(data).value.then(function(data){
    g.next(data)
  })
})
```




    Promise {
      _c: [],
      _a: undefined,
      _s: 0,
      _d: false,
      _v: undefined,
      _h: 0,
      _n: false }



    # ES6快速入门
    
    本文主要是为已经学过python的人而写的攻略文,数据科学家除了要会收集分析数据,同样需要掌握一些web技术,
    这样才可以做数据可视化.Js作为web技术的标志和基础自然是不可能不学习的.直接从ES6标准入手的好处是:
    
    + 语法糖丰富
    
        低版本的Js语法简单而且坑多,使用起来各种不方便,会给习惯python的数据科学研究人员造成学习困难,
        ES6新增了大量语法糖.在使用上可以给被python惯坏了的人一定程度上减少学习成本.
    
    + 接近Python的开发习惯
    
        Python是模块化编程的语言,而Js在设计初期就没考虑太多模块化的问题,低版本的js在编写时模块化方面
        会让被python惯坏了的人非常不喜欢,ES6使用类似python的`import`语句,相对容易接受.
    
    + 可以顺利过渡学习JSX和react
    
        前端开发框架react使用组件化思路构建web前端应用,相对更加接近python等语言中编写GUI的方式,而且
        该框架比较程序员思维,类似搭积木式的编写方式也更加接近python用户习惯
    
    事实上Js语言是比python有活力的多的一门编程语言,它充分体现着开源的魅力和模块化的威力,在google v8引擎的
    性能保证下,Js语言是当今最受欢迎并且发展最快的语言没有之一,作为一个pythoner我们也确实该看看它有些什么可取之处.
    
    在后面的几部分中我们会从分以下几个步骤与python对比着快速入门ES6
    
    1. 环境与基本工具链:
    
        + node.js,npm包管理工具与babel转换器
        + 文档,代码风格检验与测试框架
        + 工作流工具链
    
    2. 基本语法
    
        + 值与运算
        + 基本容器
        + 逻辑表达式,控制结构与特殊对象Fuction
        + 生成器对象
        + 特殊对象RegExp和Date
        + 变量,声明与作用域
        + 对象,类与面向对象编程
        + 异步操作
        + 二进制数组
        + 代理与反射
        + 模块化编程
    
    3. ES7新特性
    
        + 装饰器
        
    本文主要参考自阮一峰大大的书`<ECMAScript 6 入门>`,这本书讲解ES6语法相当好,评论中也有不少有用的知识,只是ES6标准事实上
    基本上得靠babel转换器实现,而它又是一个高度模块化的项目,加上js资源非常丰富,同样的功能有大量的实现,部署环境就已经是一个非
    常不容易的工程了,相比而言反而ES6语法部分学起来反而没啥太大难度.简单说就是这本书并不适用于我所面向的对象.所以只能在大量参
    考的基础上加上具体的使用方式和环境配置方面的文字了.
    {
      "name": "quick_start",
      "version": "1.0.0",
      "description": "ES6快速入门",
      "main": "index.js",
      "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1"
      },
      "author": "",
      "license": "ISC",
      "devDependencies": {
        "babel-cli": "^6.7.5",
        "babel-core": "^6.7.6",
        "babel-plugin-syntax-decorators": "^6.3.13",
        "babel-plugin-transform-decorators-legacy": "^1.3.4",
        "babel-plugin-transform-runtime": "^6.7.5",
        "babel-polyfill": "^6.7.4",
        "babel-preset-es2015": "^6.6.0",
        "babel-preset-stage-0": "^6.5.0",
        "babel-preset-stage-1": "^6.5.0",
        "babel-preset-stage-2": "^6.5.0",
        "babel-preset-stage-3": "^6.5.0",
        "babel-register": "^6.7.2",
        "co": "^4.6.0",
        "eslint": "^2.7.0",
        "node-fetch": "^1.5.1",
        "thunkify": "^2.1.2"
      },
      "babel": {
        "presets": [
          "es2015",
          "stage-0"
        ],
        "plugins": [
          "syntax-decorators",
          "transform-runtime"
        ]
      },
      "dependencies": {
        "babel-runtime": "^6.6.1"
      }
    }
    


手动执行其实就是用then方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。


```javascript
function run(gen){
  var g = gen();

  function next(data){
    var result = g.next(data)
    if (result.done) return result.value;
    result.value.then(function(data){
      next(data)
    })
  }

  next()
}

run(gen)
```




    undefined



    # ES6快速入门
    
    本文主要是为已经学过python的人而写的攻略文,数据科学家除了要会收集分析数据,同样需要掌握一些web技术,
    这样才可以做数据可视化.Js作为web技术的标志和基础自然是不可能不学习的.直接从ES6标准入手的好处是:
    
    + 语法糖丰富
    
        低版本的Js语法简单而且坑多,使用起来各种不方便,会给习惯python的数据科学研究人员造成学习困难,
        ES6新增了大量语法糖.在使用上可以给被python惯坏了的人一定程度上减少学习成本.
    
    + 接近Python的开发习惯
    
        Python是模块化编程的语言,而Js在设计初期就没考虑太多模块化的问题,低版本的js在编写时模块化方面
        会让被python惯坏了的人非常不喜欢,ES6使用类似python的`import`语句,相对容易接受.
    
    + 可以顺利过渡学习JSX和react
    
        前端开发框架react使用组件化思路构建web前端应用,相对更加接近python等语言中编写GUI的方式,而且
        该框架比较程序员思维,类似搭积木式的编写方式也更加接近python用户习惯
    
    事实上Js语言是比python有活力的多的一门编程语言,它充分体现着开源的魅力和模块化的威力,在google v8引擎的
    性能保证下,Js语言是当今最受欢迎并且发展最快的语言没有之一,作为一个pythoner我们也确实该看看它有些什么可取之处.
    
    在后面的几部分中我们会从分以下几个步骤与python对比着快速入门ES6
    
    1. 环境与基本工具链:
    
        + node.js,npm包管理工具与babel转换器
        + 文档,代码风格检验与测试框架
        + 工作流工具链
    
    2. 基本语法
    
        + 值与运算
        + 基本容器
        + 逻辑表达式,控制结构与特殊对象Fuction
        + 生成器对象
        + 特殊对象RegExp和Date
        + 变量,声明与作用域
        + 对象,类与面向对象编程
        + 异步操作
        + 二进制数组
        + 代理与反射
        + 模块化编程
    
    3. ES7新特性
    
        + 装饰器
        
    本文主要参考自阮一峰大大的书`<ECMAScript 6 入门>`,这本书讲解ES6语法相当好,评论中也有不少有用的知识,只是ES6标准事实上
    基本上得靠babel转换器实现,而它又是一个高度模块化的项目,加上js资源非常丰富,同样的功能有大量的实现,部署环境就已经是一个非
    常不容易的工程了,相比而言反而ES6语法部分学起来反而没啥太大难度.简单说就是这本书并不适用于我所面向的对象.所以只能在大量参
    考的基础上加上具体的使用方式和环境配置方面的文字了.
    {
      "name": "quick_start",
      "version": "1.0.0",
      "description": "ES6快速入门",
      "main": "index.js",
      "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1"
      },
      "author": "",
      "license": "ISC",
      "devDependencies": {
        "babel-cli": "^6.7.5",
        "babel-core": "^6.7.6",
        "babel-plugin-syntax-decorators": "^6.3.13",
        "babel-plugin-transform-decorators-legacy": "^1.3.4",
        "babel-plugin-transform-runtime": "^6.7.5",
        "babel-polyfill": "^6.7.4",
        "babel-preset-es2015": "^6.6.0",
        "babel-preset-stage-0": "^6.5.0",
        "babel-preset-stage-1": "^6.5.0",
        "babel-preset-stage-2": "^6.5.0",
        "babel-preset-stage-3": "^6.5.0",
        "babel-register": "^6.7.2",
        "co": "^4.6.0",
        "eslint": "^2.7.0",
        "node-fetch": "^1.5.1",
        "thunkify": "^2.1.2"
      },
      "babel": {
        "presets": [
          "es2015",
          "stage-0"
        ],
        "plugins": [
          "syntax-decorators",
          "transform-runtime"
        ]
      },
      "dependencies": {
        "babel-runtime": "^6.6.1"
      }
    }
    


上面代码中，只要Generator函数还没执行到最后一步，next函数就调用自身，以此实现自动执行。

co模块的源码
co就是上面那个自动执行器的扩展，它的源码只有几十行，非常简单。

首先，co函数接受Generator函数作为参数，返回一个 Promise 对象。


```javascript
function co(gen) {
  var ctx = this
  return new Promise(function(resolve, reject) {
  })
}
```




    'use strict'



在返回的Promise对象里面，co先检查参数gen是否为Generator函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将Promise对象的状态改为resolved。


```javascript
function co(gen) {
  var ctx = this

  return new Promise(function(resolve, reject) {
    if (typeof gen === 'function') gen = gen.call(ctx)
    if (!gen || typeof gen.next !== 'function') return resolve(gen)
  })
}
```




    'use strict'



接着，co将Generator函数的内部指针对象的next方法，包装成onFulfilled函数。这主要是为了能够捕捉抛出的错误。


```javascript
function co(gen) {
  var ctx = this

  return new Promise(function(resolve, reject) {
    if (typeof gen === 'function') gen = gen.call(ctx)
    if (!gen || typeof gen.next !== 'function') return resolve(gen)

    onFulfilled()
    function onFulfilled(res) {
      var ret
      try {
        ret = gen.next(res)
      } catch (e) {
        return reject(e)
      }
      next(ret)
    }
  })
}
```




    'use strict'



最后，就是关键的next函数，它会反复调用自身。


```javascript
function next(ret) {
  if (ret.done) return resolve(ret.value)
  var value = toPromise.call(ctx, ret.value)
  if (value && isPromise(value)) return value.then(onFulfilled, onRejected)
  return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, '
    + 'but the following object was passed: "' + String(ret.value) + '"'))
}
```




    'use strict'



上面代码中，next 函数的内部代码，一共只有四行命令。

第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回。

第二行，确保每一步的返回值，是 Promise 对象。

第三行，使用 then 方法，为返回值加上回调函数，然后通过 onFulfilled 函数再次调用 next 函数。

第四行，在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为 rejected，从而终止执行。


## 处理并发的异步操作

co支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。

这时，要把并发的操作都放在数组或对象里面，跟在yield语句后面。



```js
// 数组的写法
co(function* () {
  var res = yield [
    Promise.resolve(1),
    Promise.resolve(2)
  ];
  console.log(res);
}).catch(onerror);

// 对象的写法
co(function* () {
  var res = yield {
    1: Promise.resolve(1),
    2: Promise.resolve(2),
  };
  console.log(res);
}).catch(onerror);
//下面是另一个例子。

co(function* () {
  var values = [n1, n2, n3];
  yield values.map(somethingAsync);
});

function* somethingAsync(x) {
  // do something async
  return y
}
```

上面的代码允许并发三个somethingAsync异步操作，等到它们全部完成，才会进行下一步。
