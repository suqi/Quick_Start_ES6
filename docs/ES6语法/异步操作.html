<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>回调函数与Event对象 &mdash; Python_Quick_Start mit 文档</title>
    
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootswatch-3.3.6/lumen/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     'mit',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.3.6/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="top" title="Python_Quick_Start mit 文档" href="../index.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body role="document">

  <div id="navbar" class="navbar navbar-inverse navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html"><span><img src="../_static/my_logo.png"></span>
          Python_Quick_Start</a>
        <span class="navbar-text navbar-version pull-left"><b>0.1.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="http://blog.hszofficial.site/">Home</a></li>
                <li><a href="http://blog.hszofficial.site/about/">About</a></li>
                <li><a href="http://blog.hszofficial.site/series/">Series</a></li>
                <li><a href="http://blog.hszofficial.site/collection/">Collections</a></li>
                <li><a href="http://blog.hszofficial.site/tags/">Tags</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Python_Quick_Start <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="simple">
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <p>python是默认的全同步实现,它的异步都是通过框架实现的,比如gevent,tornad,在3.4之后python加入了async标准包实现了语言级别的异步,但貌似买帐的人不多,也算是历史遗留问题了.</p>
<p>所谓&#8221;异步&#8221;，简单说就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。</p>
<p>比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。</p>
<p>相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。</p>
<p>Js没有这些包袱,所以在异步方案方便确实做得比python好,js中异步处理并发主要手段是:</p>
<ul class="simple">
<li>回调函数与Event对象</li>
<li>Promise对象</li>
<li>生成器与协程</li>
</ul>
<div class="section" id="event">
<span id="event"></span><h1>回调函数与Event对象<a class="headerlink" href="#event" title="永久链接至标题">¶</a></h1>
<p>这是最原始也是最好理解的手段,所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。它的英语名字callback，直译过来就是&#8221;重新调用&#8221;。python中的tornado就是异步回调实现的服务器</p>
<p>在js中这是非常常见的技术,比如读取一个文件:</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="o">*</span> <span class="nx">as</span> <span class="nx">fs</span> <span class="nx">from</span> <span class="s2">&quot;fs&quot;</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="s1">&#39;use strict&#39;</span>
</pre></div>
</div>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="s1">&#39;babel-polyfill&#39;</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="p">{}</span>
</pre></div>
</div>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="s1">&#39;./README.md&#39;</span><span class="p">,</span> <span class="s1">&#39;utf-8&#39;</span><span class="p">,</span><span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">err</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">20</span><span class="p">))</span>
<span class="p">})</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>undefined



# ES6快速入门

本文主要是为已经学
</pre></div>
</div>
<p>上面代码中，readFile函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了<code class="docutils literal"><span class="pre">./README.md</span></code>这个文件以后，回调函数才会执行。</p>
<p>一个有趣的问题是，为什么Node.js约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是null）？原因是执行分成两段，在这两段之间抛出的错误，程序无法捕捉，只能当作参数，传入第二段。</p>
<div class="section" id="event">
<span id="id1"></span><h2>Event对象<a class="headerlink" href="#event" title="永久链接至标题">¶</a></h2>
<p>Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态。</p>
<p>事件通常与回调函数结合使用,这与tkinter中类似</p>
<p>这边我们只讲html中的标准Eventapi</p>
<div class="section" id="event-handlers">
<span id="event-handlers"></span><h3>事件句柄　(Event Handlers)<a class="headerlink" href="#event-handlers" title="永久链接至标题">¶</a></h3>
<p>HTML事件触发浏览器中的行为，比如当用户点击某个 HTML 元素时启动一段 JavaScript。下面是一个属性列表，可将之插入 HTML 标签以定义事件的行为。
属性  |此事件发生在何时
&#8212;|&#8212;
onabort |图像的加载被中断。
onblur  |元素失去焦点。
onchange    |域的内容被改变。
onclick |当用户点击某个对象时调用的事件句柄。
ondblclick  |当用户双击某个对象时调用的事件句柄。
onerror |在加载文档或图像时发生错误。
onfocus|    元素获得焦点。
onkeydown   |某个键盘按键被按下。
onkeypress  |某个键盘按键被按下并松开。
onkeyup |某个键盘按键被松开。
onload  |一张页面或一幅图像完成加载。
onmousedown|    鼠标按钮被按下。
onmousemove|    鼠标被移动。
onmouseout| 鼠标从某元素移开。
onmouseover|    鼠标移到某元素之上。
onmouseup   |鼠标按键被松开。
onreset |重置按钮被点击。
onresize    |窗口或框架被重新调整大小。
onselect    |文本被选中。
onsubmit    |确认按钮被点击。
onunload    |用户退出页面。</p>
</div>
<div class="section" id="">
<span id="id2"></span><h3>鼠标 / 键盘属性<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<p>属性  |描述
&#8212;|&#8212;
altKey  |返回当事件被触发时，&#8221;ALT&#8221; 是否被按下。
button  |返回当事件被触发时，哪个鼠标按钮被点击。
clientX |返回当事件被触发时，鼠标指针的水平坐标。
clientY |返回当事件被触发时，鼠标指针的垂直坐标。
ctrlKey|    返回当事件被触发时，&#8221;CTRL&#8221; 键是否被按下。
metaKey |返回当事件被触发时，&#8221;meta&#8221; 键是否被按下。
relatedTarget   |返回与事件的目标节点相关的节点。
screenX |返回当某个事件被触发时，鼠标指针的水平坐标。
screenY |返回当某个事件被触发时，鼠标指针的垂直坐标。
shiftKey    |返回当事件被触发时，&#8221;SHIFT&#8221; 键是否被按下。</p>
</div>
<div class="section" id="event">
<span id="id3"></span><h3>标准 Event 属性<a class="headerlink" href="#event" title="永久链接至标题">¶</a></h3>
<p>下面列出了 2 级 DOM 事件标准定义的属性。</p>
<p>属性  |描述
&#8212;|&#8212;
bubbles |返回布尔值，指示事件是否是起泡事件类型。
cancelable  |返回布尔值，指示事件是否可拥可取消的默认动作。
currentTarget   |返回其事件监听器触发该事件的元素。
eventPhase  |返回事件传播的当前阶段。
target  |返回触发此事件的元素（事件的目标节点）。
timeStamp   |返回事件生成的日期和时间。
type    |返回当前 Event 对象表示的事件的名称。</p>
</div>
<div class="section" id="event">
<span id="id4"></span><h3>标准 Event 方法<a class="headerlink" href="#event" title="永久链接至标题">¶</a></h3>
<p>下面列出了 2 级 DOM 事件标准定义的方法。IE 的事件模型不支持这些方法：</p>
<p>方法  |描述
&#8212;|&#8212;
initEvent() |初始化新创建的 Event 对象的属性。
preventDefault()    |通知浏览器不要执行与事件关联的默认动作。
stopPropagation()   |不再派发事件。</p>
</div>
</div>
<div class="section" id="">
<span id="id5"></span><h2>回调的缺点<a class="headerlink" href="#" title="永久链接至标题">¶</a></h2>
<p>回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="nx">fileA</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="nx">fileB</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">})</span>
<span class="p">})</span>
</pre></div>
</div>
<p>如果依次读取多个文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。这种情况就称为&#8221;回调函数噩梦&#8221;（callback hell）</p>
</div>
</div>
<div class="section" id="promise">
<span id="promise"></span><h1>Promise<a class="headerlink" href="#promise" title="永久链接至标题">¶</a></h1>
<p>promise翻译成中文就是保证,是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。</p>
<p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise是一个对象，从它可以获取异步操作的消息。Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。</p>
<p>Promise对象有以下两个特点。</p>
<ol class="simple">
<li>对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</li>
<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li>
</ol>
<p>有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。</p>
<p>Promise也有一些缺点:</p>
<ul class="simple">
<li>无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li>
<li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li>
<li>当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li>
</ul>
<p>如果某些事件不断地反复发生，一般来说，使用stream模式(生成器)是比部署Promise更好的选择。</p>
<div class="section" id="">
<span id="id6"></span><h2>基本用法<a class="headerlink" href="#" title="永久链接至标题">¶</a></h2>
<p>Promise对象是一个构造函数，参数是一个函数对象,用来生成Promise实例</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ... some code</span>

  <span class="k">if</span> <span class="p">(</span><span class="cm">/* 异步操作成功 */</span><span class="p">){</span>
    <span class="nx">resolve</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">reject</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">})</span>
</pre></div>
</div>
<p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由JavaScript引擎提供，不用自己部署。</p>
<ul>
<li><p class="first">resolve函数</p>
<p>将Promise对象的状态从“未完成”变为“成功”（即从Pending变为Resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去</p>
</li>
<li><p class="first">reject函数</p>
<p>将Promise对象的状态从“未完成”变为“失败”（即从Pending变为Rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
</li>
</ul>
<p>Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// success</span>
<span class="p">},</span> <span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// failure</span>
<span class="p">});</span>
</pre></div>
</div>
<p>then方法可以接受两个回调函数作为参数。</p>
<ul class="simple">
<li>第一个回调函数是Promise对象的状态变为Resolved时调用</li>
<li>第二个回调函数是Promise对象的状态变为Reject时调用。</li>
</ul>
<p>其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</p>
<blockquote>
<div>一个简单的例子</div></blockquote>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">timeout</span><span class="p">(</span><span class="nx">ms</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">ms</span><span class="p">,</span> <span class="s1">&#39;done&#39;</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="nx">timeout</span><span class="p">(</span><span class="mi">100</span><span class="p">).</span><span class="nx">then</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
<span class="p">})</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>Promise { &lt;pending&gt; }



done
</pre></div>
</div>
<p>上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为Resolved，就会触发then方法绑定的回调函数。</p>
<p>Promise新建后就会立即执行。</p>
<blockquote>
<div>异步实现</div></blockquote>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">)</span>
  <span class="nx">resolve</span><span class="p">()</span>
<span class="p">})</span>

<span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;2.&#39;</span><span class="p">)</span>
<span class="p">})</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;3&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="mi">1</span>
<span class="mi">3</span>





<span class="n">undefined</span>



<span class="mf">2.</span>
</pre></div>
</div>
<p>可以看到实际上异步主要就是在then上实现了</p>
<div class="section" id="">
<span id="id7"></span><h3>异步实现图片加载<a class="headerlink" href="#" title="永久链接至标题">¶</a></h3>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">loadImageAsync</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">image</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Image</span><span class="p">()</span>

    <span class="nx">image</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">resolve</span><span class="p">(</span><span class="nx">image</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">image</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;Could not load image at &#39;</span> <span class="o">+</span> <span class="nx">url</span><span class="p">))</span>
    <span class="p">}</span>

    <span class="nx">image</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">url</span>
  <span class="p">})</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="nx">loadImageAsync</span><span class="p">(</span><span class="s1">&#39;./source/jsextend.png&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>Promise { &lt;rejected&gt; [ReferenceError: Image is not defined] }
</pre></div>
</div>
</div>
<div class="section" id="ajax">
<span id="ajax"></span><h3>ajax操作<a class="headerlink" href="#ajax" title="永久链接至标题">¶</a></h3>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">getJSON</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">client</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">()</span>
    <span class="nx">client</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s2">&quot;GET&quot;</span><span class="p">,</span> <span class="nx">url</span><span class="p">)</span>
    <span class="nx">client</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="nx">handler</span>
    <span class="nx">client</span><span class="p">.</span><span class="nx">responseType</span> <span class="o">=</span> <span class="s2">&quot;json&quot;</span>
    <span class="nx">client</span><span class="p">.</span><span class="nx">setRequestHeader</span><span class="p">(</span><span class="s2">&quot;Accept&quot;</span><span class="p">,</span> <span class="s2">&quot;application/json&quot;</span><span class="p">)</span>
    <span class="nx">client</span><span class="p">.</span><span class="nx">send</span><span class="p">()</span>

    <span class="kd">function</span> <span class="nx">handler</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="k">this</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">!==</span> <span class="mi">4</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="mi">200</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">resolve</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">response</span><span class="p">)</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">statusText</span><span class="p">))</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">})</span>

  <span class="k">return</span> <span class="nx">promise</span>
<span class="p">}</span>

<span class="nx">getJSON</span><span class="p">(</span><span class="s2">&quot;/posts.json&quot;</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">json</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Contents: &#39;</span> <span class="o">+</span> <span class="nx">json</span><span class="p">)</span>
<span class="p">},</span> <span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="s1">&#39;出错了&#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">)</span>
<span class="p">})</span>
</pre></div>
</div>
<p>getJSON是对XMLHttpRequest对象的封装，用于发出一个针对JSON数据的HTTP请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。</p>
<p>如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误</p>
<p>resolve函数的参数除了正常的值以外，还可能是另一个Promise实例，表示异步操作的结果有可能是一个值，也有可能是另一个异步操作</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;fail&#39;</span><span class="p">))</span>
  <span class="p">},</span> <span class="mi">3000</span><span class="p">)</span>
<span class="p">})</span>
<span class="kd">var</span> <span class="nx">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">resolve</span><span class="p">(</span><span class="nx">p1</span><span class="p">)</span>
  <span class="p">},</span> <span class="mi">1000</span><span class="p">)</span>
<span class="p">})</span>
<span class="nx">p2</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">result</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">))</span>
<span class="nx">p2</span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>Promise { &lt;pending&gt; }



[Error: fail]
</pre></div>
</div>
<p>上面代码中，p1是一个Promise，3秒之后变为rejected。p2的状态由p1决定，1秒之后，p2调用resolve方法，但是此时p1的状态还没有改变，因此p2的状态也不会变。又过了2秒，p1变为rejected，p2也跟着变为rejected。</p>
</div>
</div>
<div class="section" id="then">
<span id="then"></span><h2>实例方法then()<a class="headerlink" href="#then" title="永久链接至标题">¶</a></h2>
<p>Promise实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为Promise实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。</p>
<p>then方法返回的是一个<strong>新的Promise实例</strong>（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">getJSON</span><span class="p">(</span><span class="s2">&quot;/posts.json&quot;</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">json</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">json</span><span class="p">.</span><span class="nx">post</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">post</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">})</span>
</pre></div>
</div>
<p>上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>
<p>采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">getJSON</span><span class="p">(</span><span class="s2">&quot;/post/1.json&quot;</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">post</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">getJSON</span><span class="p">(</span><span class="nx">post</span><span class="p">.</span><span class="nx">commentURL</span><span class="p">)</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="nx">funcA</span><span class="p">(</span><span class="nx">comments</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;Resolved: &quot;</span><span class="p">,</span> <span class="nx">comments</span><span class="p">)</span>
<span class="p">},</span> <span class="kd">function</span> <span class="nx">funcB</span><span class="p">(</span><span class="nx">err</span><span class="p">){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;Rejected: &quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">})</span>
</pre></div>
</div>
<p>上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为Resolved，就调用funcA，如果状态变为Rejected，就调用funcB。</p>
<p>如果采用箭头函数，上面的代码可以写得更简洁。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">getJSON</span><span class="p">(</span><span class="s2">&quot;/post/1.json&quot;</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span>
  <span class="nx">post</span> <span class="o">=&gt;</span> <span class="nx">getJSON</span><span class="p">(</span><span class="nx">post</span><span class="p">.</span><span class="nx">commentURL</span><span class="p">)</span>
<span class="p">).</span><span class="nx">then</span><span class="p">(</span>
  <span class="nx">comments</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;Resolved: &quot;</span><span class="p">,</span> <span class="nx">comments</span><span class="p">),</span>
  <span class="nx">err</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;Rejected: &quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="promisecatch">
<span id="promisecatch"></span><h2>Promise对象的catch()<a class="headerlink" href="#promisecatch" title="永久链接至标题">¶</a></h2>
<p>catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">getJSON</span><span class="p">(</span><span class="s2">&quot;/posts.json&quot;</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">posts</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;发生错误！&#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">)</span>
<span class="p">})</span>
</pre></div>
</div>
<p>上面代码中，getJSON方法返回一个Promise对象，如果该对象状态变为Resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为Rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span>p.then((val) =&gt; console.log(&quot;fulfilled:&quot;, val))
  .catch((err) =&gt; console.log(&quot;rejected:&quot;, err));

// 等同于

p.then((val) =&gt; console.log(fulfilled:&quot;, val))
  .then(null, (err) =&gt; console.log(&quot;rejected:&quot;, err))
</pre></div>
</div>
<p>下面是一个例子。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;test&#39;</span><span class="p">)</span>
<span class="p">})</span>
<span class="nx">promise</span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span>
<span class="p">})</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>Promise { &lt;pending&gt; }



[Error: test]
</pre></div>
</div>
<p>上面代码中，promise抛出一个错误，就被catch方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;test&#39;</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">})</span>
<span class="nx">promise</span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span>
<span class="p">})</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>Promise { &lt;pending&gt; }



[Error: test]
</pre></div>
</div>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;test&#39;</span><span class="p">))</span>
<span class="p">})</span>
<span class="nx">promise</span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span>
<span class="p">})</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>Promise { &lt;pending&gt; }



[Error: test]
</pre></div>
</div>
<p>比较上面两种写法，可以发现reject方法的作用，等同于抛出错误。
如果Promise状态已经变成Resolved，再抛出错误是无效的。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;ok&#39;</span><span class="p">)</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;test&#39;</span><span class="p">)</span>
<span class="p">})</span>
<span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">})</span>
       <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">})</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>Promise { &lt;pending&gt; }



ok
</pre></div>
</div>
<p>上面代码中，Promise在resolve语句后面，再抛出错误，不会被捕获，等于没有抛出。</p>
<p>Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">getJSON</span><span class="p">(</span><span class="s2">&quot;/post/1.json&quot;</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">post</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">getJSON</span><span class="p">(</span><span class="nx">post</span><span class="p">.</span><span class="nx">commentURL</span><span class="p">);</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">comments</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// some code</span>
<span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 处理前面三个Promise产生的错误</span>
<span class="p">})</span>
</pre></div>
</div>
<p>上面代码中，一共有三个Promise对象：一个由getJSON产生，两个由then产生。它们之中任何一个抛出的错误，都会被最后一个catch捕获。</p>
<p>一般来说，不要在then方法里面定义Reject状态的回调函数（即then的第二个参数），总是使用catch方法。这种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用catch方法，而不使用then方法的第二个参数。</p>
<p>跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">someAsyncThing</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 下面一行会报错，因为x没有声明</span>
    <span class="nx">resolve</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="nx">someAsyncThing</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;everything is great&#39;</span><span class="p">)</span>
<span class="p">})</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>Promise { &lt;pending&gt; }
</pre></div>
</div>
<p>上面代码中，someAsyncThing函数产生的Promise对象会报错，但是由于没有指定catch方法，这个错误不会被捕获，也不会传递到外层代码，导致运行后没有任何输出。注意，Chrome浏览器不遵守这条规定，它会抛出错误“ReferenceError: x is not defined”。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">resolve</span><span class="p">(</span><span class="s2">&quot;ok&quot;</span><span class="p">)</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;test&#39;</span><span class="p">)</span> <span class="p">},</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">})</span>
<span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">})</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>Promise { &lt;pending&gt; }



ok


Error: test
    at null._onTimeout (evalmachine.&lt;anonymous&gt;:6:11)
    at Timer.listOnTimeout (timers.js:92:15)
</pre></div>
</div>
<p>上面代码中，Promise指定在下一轮“事件循环”再抛出错误，结果由于没有指定使用try...catch语句，就冒泡到最外层，成了未捕获的错误。因为此时，Promise的函数体已经运行结束了，所以这个错误是在Promise函数体外抛出的。</p>
<p>Node.js有一个unhandledRejection事件，专门监听未捕获的reject错误。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">someAsyncThing</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 下面一行会报错，因为x没有声明</span>
    <span class="nx">resolve</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="nx">someAsyncThing</span><span class="p">()</span>
<span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;oh no&#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">)</span>
<span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;carry on&#39;</span><span class="p">)</span>
<span class="p">});</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>Promise { &lt;pending&gt; }



oh no [ReferenceError: x is not defined]
carry on
</pre></div>
</div>
<p>上面代码运行完catch方法指定的回调函数，会接着运行后面那个then方法指定的回调函数。如果没有报错，则会跳过catch方法。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">()</span>
<span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;oh no&#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
<span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;carry on&#39;</span><span class="p">);</span>
<span class="p">})</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>Promise { &lt;pending&gt; }



carry on
</pre></div>
</div>
<p>上面的代码因为没有报错，跳过了catch方法，直接执行后面的then方法。此时，要是then方法里面报错，就与前面的catch无关了。</p>
<p>catch方法之中，还能再抛出错误。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">someAsyncThing</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 下面一行会报错，因为x没有声明</span>
    <span class="nx">resolve</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="nx">someAsyncThing</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">someOtherAsyncThing</span><span class="p">()</span>
<span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;oh no&#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">)</span>
  <span class="c1">// 下面一行会报错，因为y没有声明</span>
  <span class="nx">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;carry on&#39;</span><span class="p">)</span>
<span class="p">})</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>Promise { &lt;pending&gt; }



oh no [ReferenceError: x is not defined]


ReferenceError: y is not defined
    at evalmachine.&lt;anonymous&gt;:15:3
    at runMicrotasksCallback (node.js:326:7)
    at doNTCallback0 (node.js:419:9)
    at process._tickCallback (node.js:348:13)
</pre></div>
</div>
<p>上面代码中，catch方法抛出一个错误，因为后面没有别的catch方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="nx">someAsyncThing</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">someOtherAsyncThing</span><span class="p">();</span>
<span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;oh no&#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
  <span class="c1">// 下面一行会报错，因为y没有声明</span>
  <span class="nx">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;carry on&#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>Promise { &lt;pending&gt; }



oh no [ReferenceError: x is not defined]
carry on [ReferenceError: y is not defined]
</pre></div>
</div>
<p>上面代码中，第二个catch方法用来捕获，前一个catch方法抛出的错误。</p>
</div>
<div class="section" id="promise-all">
<span id="promise-all"></span><h2>Promise.all()<a class="headerlink" href="#promise-all" title="永久链接至标题">¶</a></h2>
<p>Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>var p = Promise.all([p1, p2, p3])
</pre></div>
</div>
<p>上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是Promise对象的实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例。）</p>
<p>p的状态由p1、p2、p3决定，分成两种情况。</p>
<ul class="simple">
<li>只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</li>
<li>只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</li>
</ul>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">promises</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">id</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">getJSON</span><span class="p">(</span><span class="s2">&quot;/post/&quot;</span> <span class="o">+</span> <span class="nx">id</span> <span class="o">+</span> <span class="s2">&quot;.json&quot;</span><span class="p">)</span>
<span class="p">})</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span><span class="nx">promises</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">posts</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">reason</span><span class="p">){</span>
  <span class="c1">// ...</span>
<span class="p">})</span>
</pre></div>
</div>
<p>上面代码中，promises是包含6个Promise实例的数组，只有这6个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。</p>
<p>下面是另一个例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">databasePromise</span> <span class="o">=</span> <span class="nx">connectDatabase</span><span class="p">()</span>

<span class="kr">const</span> <span class="nx">booksPromise</span> <span class="o">=</span> <span class="nx">databaseProimse</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">findAllBooks</span><span class="p">)</span>

<span class="kr">const</span> <span class="nx">userPromise</span> <span class="o">=</span> <span class="nx">databasePromise</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">getCurrentUser</span><span class="p">)</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span>
  <span class="nx">booksPromise</span><span class="p">,</span>
  <span class="nx">userPromise</span>
<span class="p">])</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(([</span><span class="nx">books</span><span class="p">,</span> <span class="nx">user</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="nx">pickTopRecommentations</span><span class="p">(</span><span class="nx">books</span><span class="p">,</span> <span class="nx">user</span><span class="p">))</span>
</pre></div>
</div>
<p>上面代码中，booksPromise和userPromise是两个异步操作，只有等到它们的结果都返回了，才会触发pickTopRecommentations这个回调函数。</p>
</div>
<div class="section" id="promise-race">
<span id="promise-race"></span><h2>Promise.race()<a class="headerlink" href="#promise-race" title="永久链接至标题">¶</a></h2>
<p>Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>var p = Promise.race([p1,p2,p3])
</pre></div>
</div>
<p>上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的回调函数。</p>
<p>Promise.race方法的参数与Promise.all方法一样，如果不是Promise实例，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。</p>
<p>下面是一个例子，如果指定时间内没有获得结果，就将Promise的状态变为reject，否则变为resolve。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">race</span><span class="p">([</span>
  <span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;/resource-that-may-take-a-while&#39;</span><span class="p">),</span>
  <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;request timeout&#39;</span><span class="p">)),</span> <span class="mi">5000</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">])</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">response</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">response</span><span class="p">))</span>
<span class="nx">p</span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">))</span>
</pre></div>
</div>
<p>上面代码中，如果5秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。</p>
</div>
<div class="section" id="promise-resolve">
<span id="promise-resolve"></span><h2>Promise.resolve()<a class="headerlink" href="#promise-resolve" title="永久链接至标题">¶</a></h2>
<p>有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">jsPromise</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">$</span><span class="p">.</span><span class="nx">ajax</span><span class="p">(</span><span class="s1">&#39;/whatever.json&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>上面代码将jQuery生成的deferred对象，转为一个新的Promise对象。</p>
<p>Promise.resolve等价于下面的写法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span>Promise.resolve(&#39;foo&#39;)
// 等价于
new Promise(resolve =&gt; resolve(&#39;foo&#39;))
Promise.resolve方法的参数分成四种情况。
</pre></div>
</div>
<ol>
<li><p class="first">参数是一个Promise实例</p>
<p>如果参数是Promise实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。</p>
</li>
<li><p class="first">参数是一个thenable对象</p>
<p>thenable对象指的是具有then方法的对象，比如下面这个对象。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">thenable</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">then</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">resolve</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Promise.resolve方法会将这个对象转为Promise对象，然后就立即执行thenable对象的then方法。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>let thenable = {
  then: function(resolve, reject) {
    resolve(42)
  }
}

let p1 = Promise.resolve(thenable);
p1.then(function(value) {
  console.log(value)  // 42
})
</pre></div>
</div>
<p>上面代码中，thenable对象的then方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then方法指定的回调函数，输出42。</p>
</li>
<li><p class="first">参数不是具有then方法的对象，或根本就不是对象</p>
<p>如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为Resolved。</p>
</li>
</ol>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span><span class="p">);</span>

<span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="p">})</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>Promise { &lt;pending&gt; }



Hello
</pre></div>
</div>
<p>// Hello
上面代码生成一个新的Promise对象的实例p。由于字符串Hello不属于异步操作（判断方法是它不是具有then方法的对象），返回Promise实例的状态从一生成就是Resolved，所以回调函数会立即执行。Promise.resolve方法的参数，会同时传给回调函数。</p>
<p>4.不带有任何参数</p>
<p>Promise.resolve方法允许调用时不带参数，直接返回一个Resolved状态的Promise对象。</p>
<p>所以，如果希望得到一个Promise对象，比较方便的方法就是直接调用Promise.resolve方法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">()</span>

<span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">})</span>
</pre></div>
</div>
<p>上面代码的变量p就是一个Promise对象。</p>
</div>
<div class="section" id="promise-reject">
<span id="promise-reject"></span><h2>Promise.reject()<a class="headerlink" href="#promise-reject" title="永久链接至标题">¶</a></h2>
<p>Promise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected。它的参数用法与Promise.resolve方法完全一致。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;出错了&#39;</span><span class="p">);</span>
<span class="c1">// 等同于</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;出错了&#39;</span><span class="p">))</span>

<span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="p">});</span>
<span class="c1">// 出错了</span>
</pre></div>
</div>
<p>上面代码生成一个Promise对象的实例p，状态为rejected，回调函数会立即执行。</p>
</div>
<div class="section" id="">
<span id="id8"></span><h2>两个有用的附加方法<a class="headerlink" href="#" title="永久链接至标题">¶</a></h2>
<p>ES6的Promise API提供的方法不是很多，有些有用的方法可以自己部署。下面介绍如何部署两个不在ES6之中、但很有用的方法。</p>
<div class="section" id="done">
<span id="done"></span><h3>done()<a class="headerlink" href="#done" title="永久链接至标题">¶</a></h3>
<p>Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">asyncFunc</span><span class="p">()</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">f1</span><span class="p">)</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">r1</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">f2</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">done</span><span class="p">()</span>
</pre></div>
</div>
<p>它的实现代码相当简单。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">done</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">onFulfilled</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">onFulfilled</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">)</span>
    <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">reason</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 抛出一个全局错误</span>
      <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="k">throw</span> <span class="nx">reason</span> <span class="p">},</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">})</span>
<span class="p">}</span>
</pre></div>
</div>
<p>从上面代码可见，done方法的使用，可以像then方法那样用，提供Fulfilled和Rejected状态的回调函数，也可以不提供任何参数。但不管怎样，done都会捕捉到任何可能出现的错误，并向全局抛出。</p>
</div>
<div class="section" id="finally">
<span id="finally"></span><h3>finally()<a class="headerlink" href="#finally" title="永久链接至标题">¶</a></h3>
<p>finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。</p>
<p>下面是一个例子，服务器使用Promise处理请求，然后使用finally方法关掉服务器。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">server</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// run test</span>
  <span class="p">})</span>
  <span class="p">.</span><span class="k">finally</span><span class="p">(</span><span class="nx">server</span><span class="p">.</span><span class="nx">stop</span><span class="p">)</span>
</pre></div>
</div>
<p>它的实现也很简单。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="k">finally</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">P</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">constructor</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span>
    <span class="nx">value</span>  <span class="o">=&gt;</span> <span class="nx">P</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">callback</span><span class="p">()).</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">value</span><span class="p">),</span>
    <span class="nx">reason</span> <span class="o">=&gt;</span> <span class="nx">P</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">callback</span><span class="p">()).</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="k">throw</span> <span class="nx">reason</span> <span class="p">})</span>
  <span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码中，不管前面的Promise是fulfilled还是rejected，都会执行回调函数callback。</p>
</div>
</div>
<div class="section" id="promise">
<span id="id9"></span><h2>如何理解Promise<a class="headerlink" href="#promise" title="永久链接至标题">¶</a></h2>
<p>Promise其实可以理解为规划,如果说回调是面向对象的,那Promise就是面向全局的,它把每种可能都描述在一起,而不是分开来给不同的地方</p>
</div>
</div>
<div class="section" id="">
<span id="id10"></span><h1>生成器与协程<a class="headerlink" href="#" title="永久链接至标题">¶</a></h1>
<p>传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做&#8221;协程&#8221;（coroutine），意思是多个线程互相协作，完成异步任务。</p>
<p>协程有点像函数，又有点像线程。它的运行流程大致如下。</p>
<p>第一步，协程A开始执行。</p>
<p>第二步，协程A执行到一半，进入暂停，执行权转移到协程B。</p>
<p>第三步，（一段时间后）协程B交还执行权。</p>
<p>第四步，协程A恢复执行。</p>
<p>上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。</p>
<p>举例来说，读取文件的协程写法如下。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="o">*</span><span class="nx">asnycJob</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...其他代码</span>
  <span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">readFile</span><span class="p">(</span><span class="nx">fileA</span><span class="p">);</span>
  <span class="c1">// ...其他代码</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码的函数asyncJob是一个协程，它的奥妙就在其中的yield命令。它表示执行到此处，执行权将交给其他协程。也就是说，yield命令是异步两个阶段的分界线。</p>
<p>协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。</p>
<p>Generator函数是协程在ES6的实现，最大特点就是可以交出函数的执行权（即暂停执行）。</p>
<p>整个Generator函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。Generator函数的执行方法如下。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">(</span><span class="nx">x</span><span class="p">){</span>
  <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: 3, done: false }</span>
<span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: undefined, done: true }</span>
</pre></div>
</div>
<p>上面代码中，调用Generator函数，会返回一个内部指针（即遍历器）g 。这是Generator函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针g的next方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的yield语句，上例是执行到x + 2为止。</p>
<p>换言之，next方法的作用是分阶段执行Generator函数。每次调用next方法，会返回一个对象，表示当前阶段的信息（value属性和done属性）。value属性是yield语句后面表达式的值，表示当前阶段的值；done属性是一个布尔值，表示Generator函数是否执行完毕，即是否还有下一个阶段。</p>
<div class="section" id="generator">
<span id="generator"></span><h2>Generator函数的数据交换和错误处理<a class="headerlink" href="#generator" title="永久链接至标题">¶</a></h2>
<p>Generator函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。</p>
<p>next方法返回值的value属性，是Generator函数向外输出数据；next方法还可以接受参数，这是向Generator函数体内输入数据。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">(</span><span class="nx">x</span><span class="p">){</span>
  <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">())</span> <span class="c1">// { value: 3, done: false }</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="c1">// { value: 2, done: true }</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="n">done</span><span class="p">:</span> <span class="n">false</span> <span class="p">}</span>
<span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">done</span><span class="p">:</span> <span class="n">true</span> <span class="p">}</span>





<span class="n">undefined</span>
</pre></div>
</div>
<p>上面代码中，第一个next方法的value属性，返回表达式x + 2的值（3）。第二个next方法带有参数2，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量y接收。因此，这一步的 value 属性，返回的就是2（变量y的值）。</p>
<p>Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">(</span><span class="nx">x</span><span class="p">){</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
<span class="nx">g</span><span class="p">.</span><span class="k">throw</span><span class="p">(</span><span class="s1">&#39;出错了&#39;</span><span class="p">);</span>
<span class="c1">// 出错了</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>出错了





{ value: undefined, done: true }
</pre></div>
</div>
<p>上面代码的最后一行，Generator函数体外，使用指针对象的throw方法抛出的错误，可以被函数体内的try ...catch代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。</p>
</div>
<div class="section" id="">
<span id="id11"></span><h2>异步任务的封装<a class="headerlink" href="#" title="永久链接至标题">¶</a></h2>
<p>下面看看如何使用 Generator 函数，执行一个真实的异步任务。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nx">fetch</span> <span class="nx">from</span> <span class="s1">&#39;node-fetch&#39;</span>
<span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">(){</span>
  <span class="kd">var</span> <span class="nx">url</span> <span class="o">=</span> <span class="s1">&#39;https://api.github.com/users/github&#39;</span>
  <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">bio</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="s1">&#39;use strict&#39;</span>
</pre></div>
</div>
<p>执行</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">()</span>
<span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>

<span class="nx">result</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
  <span class="k">return</span> <span class="nx">data</span><span class="p">.</span><span class="nx">json</span><span class="p">()</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
  <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
<span class="p">})</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>Promise {
  _c: [],
  _a: undefined,
  _s: 0,
  _d: false,
  _v: undefined,
  _h: 0,
  _n: false }



How people build software.
</pre></div>
</div>
<p>上面代码中，Generator函数封装了一个异步操作，该操作先读取一个远程接口，然后从JSON格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了yield命令。</p>
<p>上面代码中，首先执行Generator函数，获取遍历器对象，然后使用next 方法（第二行），执行异步任务的第一阶段。由于Fetch模块返回的是一个Promise对象，因此要用then方法调用下一个next 方法。</p>
<p>可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</p>
</div>
<div class="section" id="thunk">
<span id="thunk"></span><h2>Thunk函数<a class="headerlink" href="#thunk" title="永久链接至标题">¶</a></h2>
<p>参数的求值策略
Thunk函数早在上个世纪60年代就诞生了。</p>
<p>那时，编程语言刚刚起步，计算机学家还在研究，编译器怎么写比较好。一个争论的焦点是&#8221;求值策略&#8221;，即函数的参数到底应该何时求值</p>
<ul>
<li><p class="first">一种意见是&#8221;传值调用&#8221;（call by value），即在进入函数体之前，就计算表达式的值，再将这个值传入函数f 。C语言就采用这种策略。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>f(x + 5)
// 传值调用时，等同于
f(6)
</pre></div>
</div>
</li>
<li><p class="first">另一种意见是&#8221;传名调用&#8221;（call by name），即直接将表达式x + 5传入函数体，只在用到它的时候求值。Haskell语言采用这种策略。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>function f(x){return x*2}
f(x + 5)
// 传名调用时，等同于
(x + 5) * 2
</pre></div>
</div>
</li>
</ul>
<p>传值调用和传名调用，哪一种比较好？回答是各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>function f(a, b){
  return b;
}

f(3 * x * x - 2 * x - 1, x)
</pre></div>
</div>
<p>上面代码中，函数f的第一个参数是一个复杂的表达式，但是函数体内根本没用到。对这个参数求值，实际上是不必要的。因此，有一些计算机学家倾向于&#8221;传名调用&#8221;，即只在执行时求值。</p>
<p>编译器的&#8221;传名调用&#8221;实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做Thunk函数。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">m</span><span class="p">){</span>
  <span class="k">return</span> <span class="nx">m</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">f</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">5</span><span class="p">);</span>

<span class="c1">// 等同于</span>

<span class="kd">var</span> <span class="nx">thunk</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">thunk</span><span class="p">){</span>
  <span class="k">return</span> <span class="nx">thunk</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码中，函数f的参数x + 5被一个函数替换了。凡是用到原参数的地方，对Thunk函数求值即可。 这就是Thunk函数的定义，它是&#8221;传名调用&#8221;的一种实现策略，用来替换某个表达式。</p>
<div class="section" id="javascriptthunk">
<span id="javascriptthunk"></span><h3>JavaScript语言的Thunk函数<a class="headerlink" href="#javascriptthunk" title="永久链接至标题">¶</a></h3>
<p>JavaScript语言是传值调用，它的Thunk函数含义有所不同。在JavaScript语言中，Thunk函数替换的不是表达式，而是多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 正常版本的readFile（多参数版本）</span>
<span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="nx">fileName</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span>

<span class="c1">// Thunk版本的readFile（单参数版本）</span>
<span class="kd">var</span> <span class="nx">readFileThunk</span> <span class="o">=</span> <span class="nx">Thunk</span><span class="p">(</span><span class="nx">fileName</span><span class="p">)</span>
<span class="nx">readFileThunk</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span>

<span class="kd">var</span> <span class="nx">Thunk</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">fileName</span><span class="p">){</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">callback</span><span class="p">){</span>
    <span class="k">return</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="nx">fileName</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码中，fs模块的readFile方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做Thunk函数。</p>
<p>任何函数，只要参数有回调函数，就能写成Thunk函数的形式。下面是一个简单的Thunk函数转换器。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">Thunk</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">fn</span><span class="p">){</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">)</span>
    <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">callback</span><span class="p">){</span>
      <span class="nx">args</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span>
      <span class="k">return</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>使用上面的转换器，生成fs.readFile的Thunk函数。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">readFileThunk</span> <span class="o">=</span> <span class="nx">Thunk</span><span class="p">(</span><span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">)</span>
<span class="nx">readFileThunk</span><span class="p">(</span><span class="nx">fileA</span><span class="p">)(</span><span class="nx">callback</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="thunkify">
<span id="thunkify"></span><h2>Thunkify模块<a class="headerlink" href="#thunkify" title="永久链接至标题">¶</a></h2>
<p>生产环境的转换器，建议使用Thunkify模块。</p>
<p>首先是安装。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>npm install thunkify
</pre></div>
</div>
<p>使用方式如下。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>var thunkify = require(&#39;thunkify&#39;);
var fs = require(&#39;fs&#39;);

var read = thunkify(fs.readFile);
read(&#39;package.json&#39;)(function(err, str){
  // ...
})
</pre></div>
</div>
<p>Thunkify的源码与上一节那个简单的转换器非常像。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">thunkify</span><span class="p">(</span><span class="nx">fn</span><span class="p">){</span>
  <span class="k">return</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">arguments</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="k">this</span>

    <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">args</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">args</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">done</span><span class="p">){</span>
      <span class="kd">var</span> <span class="nx">called</span>

      <span class="nx">args</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">called</span><span class="p">)</span> <span class="k">return</span>
        <span class="nx">called</span> <span class="o">=</span> <span class="kc">true</span>
        <span class="nx">done</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">)</span>
      <span class="p">})</span>

      <span class="k">try</span> <span class="p">{</span>
        <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span>
      <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">done</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>它的源码主要多了一个检查机制，变量called确保回调函数只运行一次。这样的设计与下文的Generator函数相关。请看下面的例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">callback</span><span class="p">){</span>
  <span class="kd">var</span> <span class="nx">sum</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
  <span class="nx">callback</span><span class="p">(</span><span class="nx">sum</span><span class="p">);</span>
  <span class="nx">callback</span><span class="p">(</span><span class="nx">sum</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">ft</span> <span class="o">=</span> <span class="nx">thunkify</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">print</span> <span class="o">=</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">console</span><span class="p">);</span>
<span class="nx">ft</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)(</span><span class="nx">print</span><span class="p">);</span>
<span class="c1">// 3</span>
</pre></div>
</div>
<p>上面代码中，由于thunkify只允许回调函数执行一次，所以只输出一行结果。</p>
</div>
<div class="section" id="generator">
<span id="id12"></span><h2>Generator 函数的流程管理<a class="headerlink" href="#generator" title="永久链接至标题">¶</a></h2>
<p>Thunk函数有什么用？回答是以前确实没什么用，但是ES6有了Generator函数，Thunk函数现在可以用于Generator函数的自动流程管理。</p>
<p>以读取文件为例。下面的Generator函数封装了两个异步操作。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="o">*</span> <span class="nx">as</span> <span class="nx">fs</span> <span class="nx">from</span> <span class="s2">&quot;fs&quot;</span>
<span class="kr">import</span> <span class="nx">thunkify</span> <span class="nx">from</span><span class="s1">&#39;thunkify&#39;</span>
    
<span class="kd">let</span> <span class="nx">readFile</span> <span class="o">=</span> <span class="nx">thunkify</span><span class="p">(</span><span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">)</span>

<span class="kd">let</span> <span class="nx">gen</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">(){</span>
  <span class="kd">let</span> <span class="nx">r1</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">readFile</span><span class="p">(</span><span class="s1">&#39;./README.md&#39;</span><span class="p">,</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">r1</span><span class="p">.</span><span class="nx">toString</span><span class="p">())</span>
  <span class="kd">let</span> <span class="nx">r2</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">readFile</span><span class="p">(</span><span class="s1">&#39;./package.json&#39;</span><span class="p">,</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">r2</span><span class="p">.</span><span class="nx">toString</span><span class="p">())</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="s1">&#39;use strict&#39;</span>
</pre></div>
</div>
<p>上面代码中，yield命令用于将程序的执行权移出Generator函数，那么就需要一种方法，将执行权再交还给Generator函数。</p>
<p>这种方法就是Thunk函数，因为它可以在回调函数里，将执行权交还给Generator函数。为了便于理解，我们先看如何手动执行上面这个Generator函数</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">()</span>

<span class="kd">var</span> <span class="nx">r1</span> <span class="o">=</span> <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
<span class="nx">r1</span><span class="p">.</span><span class="nx">value</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">data</span><span class="p">){</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">err</span>
  <span class="kd">var</span> <span class="nx">r2</span> <span class="o">=</span> <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
  <span class="nx">r2</span><span class="p">.</span><span class="nx">value</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">data</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">err</span>
    <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">})</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>undefined



# ES6快速入门

本文主要是为已经学过python的人而写的攻略文,数据科学家除了要会收集分析数据,同样需要掌握一些web技术,
这样才可以做数据可视化.Js作为web技术的标志和基础自然是不可能不学习的.直接从ES6标准入手的好处是:

+ 语法糖丰富

    低版本的Js语法简单而且坑多,使用起来各种不方便,会给习惯python的数据科学研究人员造成学习困难,
    ES6新增了大量语法糖.在使用上可以给被python惯坏了的人一定程度上减少学习成本.

+ 接近Python的开发习惯

    Python是模块化编程的语言,而Js在设计初期就没考虑太多模块化的问题,低版本的js在编写时模块化方面
    会让被python惯坏了的人非常不喜欢,ES6使用类似python的`import`语句,相对容易接受.

+ 可以顺利过渡学习JSX和react

    前端开发框架react使用组件化思路构建web前端应用,相对更加接近python等语言中编写GUI的方式,而且
    该框架比较程序员思维,类似搭积木式的编写方式也更加接近python用户习惯

事实上Js语言是比python有活力的多的一门编程语言,它充分体现着开源的魅力和模块化的威力,在google v8引擎的
性能保证下,Js语言是当今最受欢迎并且发展最快的语言没有之一,作为一个pythoner我们也确实该看看它有些什么可取之处.

在后面的几部分中我们会从分以下几个步骤与python对比着快速入门ES6

1. 环境与基本工具链:

    + node.js,npm包管理工具与babel转换器
    + 文档,代码风格检验与测试框架
    + 工作流工具链

2. 基本语法

    + 值与运算
    + 基本容器
    + 逻辑表达式,控制结构与特殊对象Fuction
    + 生成器对象
    + 特殊对象RegExp和Date
    + 变量,声明与作用域
    + 对象,类与面向对象编程
    + 异步操作
    + 二进制数组
    + 代理与反射
    + 模块化编程

3. ES7新特性

    + 装饰器
    
本文主要参考自阮一峰大大的书`&lt;ECMAScript 6 入门&gt;`,这本书讲解ES6语法相当好,评论中也有不少有用的知识,只是ES6标准事实上
基本上得靠babel转换器实现,而它又是一个高度模块化的项目,加上js资源非常丰富,同样的功能有大量的实现,部署环境就已经是一个非
常不容易的工程了,相比而言反而ES6语法部分学起来反而没啥太大难度.简单说就是这本书并不适用于我所面向的对象.所以只能在大量参
考的基础上加上具体的使用方式和环境配置方面的文字了.
{
  &quot;name&quot;: &quot;quick_start&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;ES6快速入门&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: {
    &quot;babel-cli&quot;: &quot;^6.7.5&quot;,
    &quot;babel-core&quot;: &quot;^6.7.6&quot;,
    &quot;babel-plugin-syntax-decorators&quot;: &quot;^6.3.13&quot;,
    &quot;babel-plugin-transform-decorators-legacy&quot;: &quot;^1.3.4&quot;,
    &quot;babel-plugin-transform-runtime&quot;: &quot;^6.7.5&quot;,
    &quot;babel-polyfill&quot;: &quot;^6.7.4&quot;,
    &quot;babel-preset-es2015&quot;: &quot;^6.6.0&quot;,
    &quot;babel-preset-stage-0&quot;: &quot;^6.5.0&quot;,
    &quot;babel-preset-stage-1&quot;: &quot;^6.5.0&quot;,
    &quot;babel-preset-stage-2&quot;: &quot;^6.5.0&quot;,
    &quot;babel-preset-stage-3&quot;: &quot;^6.5.0&quot;,
    &quot;babel-register&quot;: &quot;^6.7.2&quot;,
    &quot;eslint&quot;: &quot;^2.7.0&quot;,
    &quot;node-fetch&quot;: &quot;^1.5.1&quot;,
    &quot;thunkify&quot;: &quot;^2.1.2&quot;
  },
  &quot;babel&quot;: {
    &quot;presets&quot;: [
      &quot;es2015&quot;,
      &quot;stage-0&quot;
    ],
    &quot;plugins&quot;: [
      &quot;syntax-decorators&quot;,
      &quot;transform-runtime&quot;
    ]
  },
  &quot;dependencies&quot;: {
    &quot;babel-runtime&quot;: &quot;^6.6.1&quot;
  }
}
</pre></div>
</div>
<p>上面代码中，变量g是Generator函数的内部指针，表示目前执行到哪一步。next方法负责将指针移动到下一步，并返回该步的信息（value属性和done属性）。</p>
<p>仔细查看上面的代码，可以发现Generator函数的执行过程，其实是将同一个回调函数，反复传入next方法的value属性。这使得我们可以用递归来自动完成这个过程。</p>
</div>
<div class="section" id="thunk">
<span id="id13"></span><h2>Thunk函数的自动流程管理<a class="headerlink" href="#thunk" title="永久链接至标题">¶</a></h2>
<p>Thunk函数真正的威力，在于可以自动执行Generator函数。下面就是一个基于Thunk函数的Generator执行器。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">run</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">gen</span> <span class="o">=</span> <span class="nx">fn</span><span class="p">()</span>

  <span class="kd">function</span> <span class="nx">next</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="k">return</span>
    <span class="nx">result</span><span class="p">.</span><span class="nx">value</span><span class="p">(</span><span class="nx">next</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">next</span><span class="p">()</span>
<span class="p">}</span>

<span class="nx">run</span><span class="p">(</span><span class="nx">gen</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>undefined



# ES6快速入门

本文主要是为已经学过python的人而写的攻略文,数据科学家除了要会收集分析数据,同样需要掌握一些web技术,
这样才可以做数据可视化.Js作为web技术的标志和基础自然是不可能不学习的.直接从ES6标准入手的好处是:

+ 语法糖丰富

    低版本的Js语法简单而且坑多,使用起来各种不方便,会给习惯python的数据科学研究人员造成学习困难,
    ES6新增了大量语法糖.在使用上可以给被python惯坏了的人一定程度上减少学习成本.

+ 接近Python的开发习惯

    Python是模块化编程的语言,而Js在设计初期就没考虑太多模块化的问题,低版本的js在编写时模块化方面
    会让被python惯坏了的人非常不喜欢,ES6使用类似python的`import`语句,相对容易接受.

+ 可以顺利过渡学习JSX和react

    前端开发框架react使用组件化思路构建web前端应用,相对更加接近python等语言中编写GUI的方式,而且
    该框架比较程序员思维,类似搭积木式的编写方式也更加接近python用户习惯

事实上Js语言是比python有活力的多的一门编程语言,它充分体现着开源的魅力和模块化的威力,在google v8引擎的
性能保证下,Js语言是当今最受欢迎并且发展最快的语言没有之一,作为一个pythoner我们也确实该看看它有些什么可取之处.

在后面的几部分中我们会从分以下几个步骤与python对比着快速入门ES6

1. 环境与基本工具链:

    + node.js,npm包管理工具与babel转换器
    + 文档,代码风格检验与测试框架
    + 工作流工具链

2. 基本语法

    + 值与运算
    + 基本容器
    + 逻辑表达式,控制结构与特殊对象Fuction
    + 生成器对象
    + 特殊对象RegExp和Date
    + 变量,声明与作用域
    + 对象,类与面向对象编程
    + 异步操作
    + 二进制数组
    + 代理与反射
    + 模块化编程

3. ES7新特性

    + 装饰器
    
本文主要参考自阮一峰大大的书`&lt;ECMAScript 6 入门&gt;`,这本书讲解ES6语法相当好,评论中也有不少有用的知识,只是ES6标准事实上
基本上得靠babel转换器实现,而它又是一个高度模块化的项目,加上js资源非常丰富,同样的功能有大量的实现,部署环境就已经是一个非
常不容易的工程了,相比而言反而ES6语法部分学起来反而没啥太大难度.简单说就是这本书并不适用于我所面向的对象.所以只能在大量参
考的基础上加上具体的使用方式和环境配置方面的文字了.
{
  &quot;name&quot;: &quot;quick_start&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;ES6快速入门&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: {
    &quot;babel-cli&quot;: &quot;^6.7.5&quot;,
    &quot;babel-core&quot;: &quot;^6.7.6&quot;,
    &quot;babel-plugin-syntax-decorators&quot;: &quot;^6.3.13&quot;,
    &quot;babel-plugin-transform-decorators-legacy&quot;: &quot;^1.3.4&quot;,
    &quot;babel-plugin-transform-runtime&quot;: &quot;^6.7.5&quot;,
    &quot;babel-polyfill&quot;: &quot;^6.7.4&quot;,
    &quot;babel-preset-es2015&quot;: &quot;^6.6.0&quot;,
    &quot;babel-preset-stage-0&quot;: &quot;^6.5.0&quot;,
    &quot;babel-preset-stage-1&quot;: &quot;^6.5.0&quot;,
    &quot;babel-preset-stage-2&quot;: &quot;^6.5.0&quot;,
    &quot;babel-preset-stage-3&quot;: &quot;^6.5.0&quot;,
    &quot;babel-register&quot;: &quot;^6.7.2&quot;,
    &quot;eslint&quot;: &quot;^2.7.0&quot;,
    &quot;node-fetch&quot;: &quot;^1.5.1&quot;,
    &quot;thunkify&quot;: &quot;^2.1.2&quot;
  },
  &quot;babel&quot;: {
    &quot;presets&quot;: [
      &quot;es2015&quot;,
      &quot;stage-0&quot;
    ],
    &quot;plugins&quot;: [
      &quot;syntax-decorators&quot;,
      &quot;transform-runtime&quot;
    ]
  },
  &quot;dependencies&quot;: {
    &quot;babel-runtime&quot;: &quot;^6.6.1&quot;
  }
}
</pre></div>
</div>
<p>上面代码的run函数，就是一个Generator函数的自动执行器。内部的next函数就是Thunk的回调函数。next函数先将指针移到Generator函数的下一步（gen.next方法），然后判断Generator函数是否结束（result.done 属性），如果没结束，就将next函数再传入Thunk函数（result.value属性），否则就直接退出。</p>
<p>有了这个执行器，执行Generator函数方便多了。不管有多少个异步操作，直接传入run函数即可。当然，前提是每一个异步操作，都要是Thunk函数，也就是说，跟在yield命令后面的必须是Thunk函数。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">gen</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">(){</span>
  <span class="kd">var</span> <span class="nx">f1</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">readFile</span><span class="p">(</span><span class="s1">&#39;./README.md&#39;</span><span class="p">)</span>
  <span class="kd">var</span> <span class="nx">f2</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">readFile</span><span class="p">(</span><span class="s1">&#39;./package.json&#39;</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">run</span><span class="p">(</span><span class="nx">gen</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">undefined</span>
</pre></div>
</div>
<p>上面代码中，函数gen封装了n个异步的读取文件操作，只要执行run函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。</p>
<p>Thunk函数并不是Generator函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制Generator函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。</p>
</div>
<div class="section" id="co">
<span id="co"></span><h2>co模块<a class="headerlink" href="#co" title="永久链接至标题">¶</a></h2>
<p>co模块是著名程序员TJ Holowaychuk于2013年6月发布的一个小工具，用于Generator函数的自动执行。</p>
<p>比如，有一个Generator函数，用于依次读取两个文件。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">gen</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">(){</span>
  <span class="kd">var</span> <span class="nx">f1</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">readFile</span><span class="p">(</span><span class="s1">&#39;/etc/fstab&#39;</span><span class="p">)</span>
  <span class="kd">var</span> <span class="nx">f2</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">readFile</span><span class="p">(</span><span class="s1">&#39;/etc/shells&#39;</span><span class="p">)</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">f1</span><span class="p">.</span><span class="nx">toString</span><span class="p">())</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">f2</span><span class="p">.</span><span class="nx">toString</span><span class="p">())</span>
<span class="p">};</span>
</pre></div>
</div>
<p>co模块可以让你不用编写Generator函数的执行器。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">co</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;co&#39;</span><span class="p">)</span>
<span class="nx">co</span><span class="p">(</span><span class="nx">gen</span><span class="p">)</span>
</pre></div>
</div>
<p>上面代码中，Generator函数只要传入co函数，就会自动执行。</p>
<p>co函数返回一个Promise对象，因此可以用then方法添加回调函数。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">co</span><span class="p">(</span><span class="nx">gen</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Generator 函数执行完成&#39;</span><span class="p">);</span>
<span class="p">})</span>
</pre></div>
</div>
<p>上面代码中，等到Generator函数执行结束，就会输出一行提示。</p>
<p>co模块的原理
为什么co可以自动执行Generator函数？</p>
<p>前面说过，Generator就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。</p>
<p>两种方法可以做到这一点:</p>
<ul class="simple">
<li>回调函数。将异步操作包装成Thunk函数，在回调函数里面交回执行权。</li>
<li>Promise 对象。将异步操作包装成Promise对象，用then方法交回执行权。</li>
</ul>
<p>co模块其实就是将两种自动执行器（Thunk函数和Promise对象），包装成一个模块。使用co的前提条件是，Generator函数的yield命令后面，只能是Thunk函数或Promise对象。</p>
<p>上面已经介绍了基于Thunk函数的自动执行器。下面来看，基于Promise对象的自动执行器。这是理解co模块必须的。</p>
<p>基于Promise对象的自动执行
还是沿用上面的例子。首先，把fs模块的readFile方法包装成一个Promise对象。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">readFile</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">fileName</span><span class="p">){</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">){</span>
    <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="nx">fileName</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">,</span> <span class="nx">data</span><span class="p">){</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span>
      <span class="nx">resolve</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
    <span class="p">})</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">gen</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">(){</span>
  <span class="kd">var</span> <span class="nx">f1</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">readFile</span><span class="p">(</span><span class="s1">&#39;./README.md&#39;</span><span class="p">)</span>
  <span class="kd">var</span> <span class="nx">f2</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">readFile</span><span class="p">(</span><span class="s1">&#39;./package.json&#39;</span><span class="p">)</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">f1</span><span class="p">.</span><span class="nx">toString</span><span class="p">())</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">f2</span><span class="p">.</span><span class="nx">toString</span><span class="p">())</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="s1">&#39;use strict&#39;</span>
</pre></div>
</div>
<p>然后，手动执行上面的Generator函数。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>

<span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
  <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">data</span><span class="p">).</span><span class="nx">value</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
    <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">})</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>Promise {
  _c: [],
  _a: undefined,
  _s: 0,
  _d: false,
  _v: undefined,
  _h: 0,
  _n: false }



# ES6快速入门

本文主要是为已经学过python的人而写的攻略文,数据科学家除了要会收集分析数据,同样需要掌握一些web技术,
这样才可以做数据可视化.Js作为web技术的标志和基础自然是不可能不学习的.直接从ES6标准入手的好处是:

+ 语法糖丰富

    低版本的Js语法简单而且坑多,使用起来各种不方便,会给习惯python的数据科学研究人员造成学习困难,
    ES6新增了大量语法糖.在使用上可以给被python惯坏了的人一定程度上减少学习成本.

+ 接近Python的开发习惯

    Python是模块化编程的语言,而Js在设计初期就没考虑太多模块化的问题,低版本的js在编写时模块化方面
    会让被python惯坏了的人非常不喜欢,ES6使用类似python的`import`语句,相对容易接受.

+ 可以顺利过渡学习JSX和react

    前端开发框架react使用组件化思路构建web前端应用,相对更加接近python等语言中编写GUI的方式,而且
    该框架比较程序员思维,类似搭积木式的编写方式也更加接近python用户习惯

事实上Js语言是比python有活力的多的一门编程语言,它充分体现着开源的魅力和模块化的威力,在google v8引擎的
性能保证下,Js语言是当今最受欢迎并且发展最快的语言没有之一,作为一个pythoner我们也确实该看看它有些什么可取之处.

在后面的几部分中我们会从分以下几个步骤与python对比着快速入门ES6

1. 环境与基本工具链:

    + node.js,npm包管理工具与babel转换器
    + 文档,代码风格检验与测试框架
    + 工作流工具链

2. 基本语法

    + 值与运算
    + 基本容器
    + 逻辑表达式,控制结构与特殊对象Fuction
    + 生成器对象
    + 特殊对象RegExp和Date
    + 变量,声明与作用域
    + 对象,类与面向对象编程
    + 异步操作
    + 二进制数组
    + 代理与反射
    + 模块化编程

3. ES7新特性

    + 装饰器
    
本文主要参考自阮一峰大大的书`&lt;ECMAScript 6 入门&gt;`,这本书讲解ES6语法相当好,评论中也有不少有用的知识,只是ES6标准事实上
基本上得靠babel转换器实现,而它又是一个高度模块化的项目,加上js资源非常丰富,同样的功能有大量的实现,部署环境就已经是一个非
常不容易的工程了,相比而言反而ES6语法部分学起来反而没啥太大难度.简单说就是这本书并不适用于我所面向的对象.所以只能在大量参
考的基础上加上具体的使用方式和环境配置方面的文字了.
{
  &quot;name&quot;: &quot;quick_start&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;ES6快速入门&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: {
    &quot;babel-cli&quot;: &quot;^6.7.5&quot;,
    &quot;babel-core&quot;: &quot;^6.7.6&quot;,
    &quot;babel-plugin-syntax-decorators&quot;: &quot;^6.3.13&quot;,
    &quot;babel-plugin-transform-decorators-legacy&quot;: &quot;^1.3.4&quot;,
    &quot;babel-plugin-transform-runtime&quot;: &quot;^6.7.5&quot;,
    &quot;babel-polyfill&quot;: &quot;^6.7.4&quot;,
    &quot;babel-preset-es2015&quot;: &quot;^6.6.0&quot;,
    &quot;babel-preset-stage-0&quot;: &quot;^6.5.0&quot;,
    &quot;babel-preset-stage-1&quot;: &quot;^6.5.0&quot;,
    &quot;babel-preset-stage-2&quot;: &quot;^6.5.0&quot;,
    &quot;babel-preset-stage-3&quot;: &quot;^6.5.0&quot;,
    &quot;babel-register&quot;: &quot;^6.7.2&quot;,
    &quot;co&quot;: &quot;^4.6.0&quot;,
    &quot;eslint&quot;: &quot;^2.7.0&quot;,
    &quot;node-fetch&quot;: &quot;^1.5.1&quot;,
    &quot;thunkify&quot;: &quot;^2.1.2&quot;
  },
  &quot;babel&quot;: {
    &quot;presets&quot;: [
      &quot;es2015&quot;,
      &quot;stage-0&quot;
    ],
    &quot;plugins&quot;: [
      &quot;syntax-decorators&quot;,
      &quot;transform-runtime&quot;
    ]
  },
  &quot;dependencies&quot;: {
    &quot;babel-runtime&quot;: &quot;^6.6.1&quot;
  }
}
</pre></div>
</div>
<p>手动执行其实就是用then方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">run</span><span class="p">(</span><span class="nx">gen</span><span class="p">){</span>
  <span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>

  <span class="kd">function</span> <span class="nx">next</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="k">return</span> <span class="nx">result</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
    <span class="nx">result</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
      <span class="nx">next</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
    <span class="p">})</span>
  <span class="p">}</span>

  <span class="nx">next</span><span class="p">()</span>
<span class="p">}</span>

<span class="nx">run</span><span class="p">(</span><span class="nx">gen</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>undefined



# ES6快速入门

本文主要是为已经学过python的人而写的攻略文,数据科学家除了要会收集分析数据,同样需要掌握一些web技术,
这样才可以做数据可视化.Js作为web技术的标志和基础自然是不可能不学习的.直接从ES6标准入手的好处是:

+ 语法糖丰富

    低版本的Js语法简单而且坑多,使用起来各种不方便,会给习惯python的数据科学研究人员造成学习困难,
    ES6新增了大量语法糖.在使用上可以给被python惯坏了的人一定程度上减少学习成本.

+ 接近Python的开发习惯

    Python是模块化编程的语言,而Js在设计初期就没考虑太多模块化的问题,低版本的js在编写时模块化方面
    会让被python惯坏了的人非常不喜欢,ES6使用类似python的`import`语句,相对容易接受.

+ 可以顺利过渡学习JSX和react

    前端开发框架react使用组件化思路构建web前端应用,相对更加接近python等语言中编写GUI的方式,而且
    该框架比较程序员思维,类似搭积木式的编写方式也更加接近python用户习惯

事实上Js语言是比python有活力的多的一门编程语言,它充分体现着开源的魅力和模块化的威力,在google v8引擎的
性能保证下,Js语言是当今最受欢迎并且发展最快的语言没有之一,作为一个pythoner我们也确实该看看它有些什么可取之处.

在后面的几部分中我们会从分以下几个步骤与python对比着快速入门ES6

1. 环境与基本工具链:

    + node.js,npm包管理工具与babel转换器
    + 文档,代码风格检验与测试框架
    + 工作流工具链

2. 基本语法

    + 值与运算
    + 基本容器
    + 逻辑表达式,控制结构与特殊对象Fuction
    + 生成器对象
    + 特殊对象RegExp和Date
    + 变量,声明与作用域
    + 对象,类与面向对象编程
    + 异步操作
    + 二进制数组
    + 代理与反射
    + 模块化编程

3. ES7新特性

    + 装饰器
    
本文主要参考自阮一峰大大的书`&lt;ECMAScript 6 入门&gt;`,这本书讲解ES6语法相当好,评论中也有不少有用的知识,只是ES6标准事实上
基本上得靠babel转换器实现,而它又是一个高度模块化的项目,加上js资源非常丰富,同样的功能有大量的实现,部署环境就已经是一个非
常不容易的工程了,相比而言反而ES6语法部分学起来反而没啥太大难度.简单说就是这本书并不适用于我所面向的对象.所以只能在大量参
考的基础上加上具体的使用方式和环境配置方面的文字了.
{
  &quot;name&quot;: &quot;quick_start&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;ES6快速入门&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: {
    &quot;babel-cli&quot;: &quot;^6.7.5&quot;,
    &quot;babel-core&quot;: &quot;^6.7.6&quot;,
    &quot;babel-plugin-syntax-decorators&quot;: &quot;^6.3.13&quot;,
    &quot;babel-plugin-transform-decorators-legacy&quot;: &quot;^1.3.4&quot;,
    &quot;babel-plugin-transform-runtime&quot;: &quot;^6.7.5&quot;,
    &quot;babel-polyfill&quot;: &quot;^6.7.4&quot;,
    &quot;babel-preset-es2015&quot;: &quot;^6.6.0&quot;,
    &quot;babel-preset-stage-0&quot;: &quot;^6.5.0&quot;,
    &quot;babel-preset-stage-1&quot;: &quot;^6.5.0&quot;,
    &quot;babel-preset-stage-2&quot;: &quot;^6.5.0&quot;,
    &quot;babel-preset-stage-3&quot;: &quot;^6.5.0&quot;,
    &quot;babel-register&quot;: &quot;^6.7.2&quot;,
    &quot;co&quot;: &quot;^4.6.0&quot;,
    &quot;eslint&quot;: &quot;^2.7.0&quot;,
    &quot;node-fetch&quot;: &quot;^1.5.1&quot;,
    &quot;thunkify&quot;: &quot;^2.1.2&quot;
  },
  &quot;babel&quot;: {
    &quot;presets&quot;: [
      &quot;es2015&quot;,
      &quot;stage-0&quot;
    ],
    &quot;plugins&quot;: [
      &quot;syntax-decorators&quot;,
      &quot;transform-runtime&quot;
    ]
  },
  &quot;dependencies&quot;: {
    &quot;babel-runtime&quot;: &quot;^6.6.1&quot;
  }
}
</pre></div>
</div>
<p>上面代码中，只要Generator函数还没执行到最后一步，next函数就调用自身，以此实现自动执行。</p>
<p>co模块的源码
co就是上面那个自动执行器的扩展，它的源码只有几十行，非常简单。</p>
<p>首先，co函数接受Generator函数作为参数，返回一个 Promise 对象。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">co</span><span class="p">(</span><span class="nx">gen</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="k">this</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">})</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="s1">&#39;use strict&#39;</span>
</pre></div>
</div>
<p>在返回的Promise对象里面，co先检查参数gen是否为Generator函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将Promise对象的状态改为resolved。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">co</span><span class="p">(</span><span class="nx">gen</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="k">this</span>

  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">gen</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="nx">gen</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">gen</span> <span class="o">||</span> <span class="k">typeof</span> <span class="nx">gen</span><span class="p">.</span><span class="nx">next</span> <span class="o">!==</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="k">return</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">gen</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="s1">&#39;use strict&#39;</span>
</pre></div>
</div>
<p>接着，co将Generator函数的内部指针对象的next方法，包装成onFulfilled函数。这主要是为了能够捕捉抛出的错误。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">co</span><span class="p">(</span><span class="nx">gen</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="k">this</span>

  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">gen</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="nx">gen</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">gen</span> <span class="o">||</span> <span class="k">typeof</span> <span class="nx">gen</span><span class="p">.</span><span class="nx">next</span> <span class="o">!==</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="k">return</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">gen</span><span class="p">)</span>

    <span class="nx">onFulfilled</span><span class="p">()</span>
    <span class="kd">function</span> <span class="nx">onFulfilled</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">ret</span>
      <span class="k">try</span> <span class="p">{</span>
        <span class="nx">ret</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span>
      <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
      <span class="p">}</span>
      <span class="nx">next</span><span class="p">(</span><span class="nx">ret</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">})</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="s1">&#39;use strict&#39;</span>
</pre></div>
</div>
<p>最后，就是关键的next函数，它会反复调用自身。</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">next</span><span class="p">(</span><span class="nx">ret</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">ret</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="k">return</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">ret</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>
  <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">toPromise</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">ret</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">&amp;&amp;</span> <span class="nx">isPromise</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span> <span class="k">return</span> <span class="nx">value</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">onFulfilled</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">onRejected</span><span class="p">(</span><span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span><span class="s1">&#39;You may only yield a function, promise, generator, array, or object, &#39;</span>
    <span class="o">+</span> <span class="s1">&#39;but the following object was passed: &quot;&#39;</span> <span class="o">+</span> <span class="nb">String</span><span class="p">(</span><span class="nx">ret</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="s1">&#39;use strict&#39;</span>
</pre></div>
</div>
<p>上面代码中，next 函数的内部代码，一共只有四行命令。</p>
<p>第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回。</p>
<p>第二行，确保每一步的返回值，是 Promise 对象。</p>
<p>第三行，使用 then 方法，为返回值加上回调函数，然后通过 onFulfilled 函数再次调用 next 函数。</p>
<p>第四行，在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为 rejected，从而终止执行。</p>
</div>
<div class="section" id="">
<span id="id14"></span><h2>处理并发的异步操作<a class="headerlink" href="#" title="永久链接至标题">¶</a></h2>
<p>co支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。</p>
<p>这时，要把并发的操作都放在数组或对象里面，跟在yield语句后面。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 数组的写法</span>
<span class="nx">co</span><span class="p">(</span><span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">yield</span> <span class="p">[</span>
    <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
    <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
  <span class="p">];</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
<span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="nx">onerror</span><span class="p">);</span>

<span class="c1">// 对象的写法</span>
<span class="nx">co</span><span class="p">(</span><span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">yield</span> <span class="p">{</span>
    <span class="mi">1</span><span class="o">:</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
    <span class="mi">2</span><span class="o">:</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
  <span class="p">};</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
<span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="nx">onerror</span><span class="p">);</span>
<span class="c1">//下面是另一个例子。</span>

<span class="nx">co</span><span class="p">(</span><span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">values</span> <span class="o">=</span> <span class="p">[</span><span class="nx">n1</span><span class="p">,</span> <span class="nx">n2</span><span class="p">,</span> <span class="nx">n3</span><span class="p">];</span>
  <span class="k">yield</span> <span class="nx">values</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">somethingAsync</span><span class="p">);</span>
<span class="p">});</span>

<span class="kd">function</span><span class="o">*</span> <span class="nx">somethingAsync</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// do something async</span>
  <span class="k">return</span> <span class="nx">y</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码允许并发三个somethingAsync异步操作，等到它们全部完成，才会进行下一步。</p>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="../_sources/ES6语法/异步操作.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; 版权所有 2016, hsz.<br/>
      由 <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.5 创建。<br/>
    </p>
  </div>
</footer>
  </body>
</html>